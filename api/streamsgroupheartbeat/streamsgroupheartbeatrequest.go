package streamsgroupheartbeat

import (
	"bytes"
	"errors"
	"io"

	"github.com/scholzj/go-kafka-protocol/protocol"
)

const (
	StreamsGroupHeartbeatRequestApiKey        = 88
	StreamsGroupHeartbeatRequestHeaderVersion = 1
)

// StreamsGroupHeartbeatRequest represents a request message.
type StreamsGroupHeartbeatRequest struct {
	// The group identifier.
	GroupId string `json:"groupid" versions:"0-999"`
	// The member ID generated by the streams consumer. The member ID must be kept during the entire lifetime of the streams consumer process.
	MemberId string `json:"memberid" versions:"0-999"`
	// The current member epoch; 0 to join the group; -1 to leave the group; -2 to indicate that the static member will rejoin.
	MemberEpoch int32 `json:"memberepoch" versions:"0-999"`
	// The current endpoint epoch of this client, represents the latest endpoint epoch this client received
	EndpointInformationEpoch int32 `json:"endpointinformationepoch" versions:"0-999"`
	// null if not provided or if it didn't change since the last heartbeat; the instance ID for static membership otherwise.
	InstanceId *string `json:"instanceid" versions:"0-999"`
	// null if not provided or if it didn't change since the last heartbeat; the rack ID of the member otherwise.
	RackId *string `json:"rackid" versions:"0-999"`
	// -1 if it didn't change since the last heartbeat; the maximum time in milliseconds that the coordinator will wait on the member to revoke its tasks otherwise.
	RebalanceTimeoutMs int32 `json:"rebalancetimeoutms" versions:"0-999"`
	// The topology metadata of the streams application. Used to initialize the topology of the group and to check if the topology corresponds to the topology initialized for the group. Only sent when memberEpoch = 0, must be non-empty. Null otherwise.
	Topology StreamsGroupHeartbeatRequestTopology `json:"topology" versions:"0-999"`
	// Currently owned active tasks for this client. Null if unchanged since last heartbeat.
	ActiveTasks []TaskIds `json:"activetasks" versions:"0-999"`
	// Currently owned standby tasks for this client. Null if unchanged since last heartbeat.
	StandbyTasks []TaskIds `json:"standbytasks" versions:"0-999"`
	// Currently owned warm-up tasks for this client. Null if unchanged since last heartbeat.
	WarmupTasks []TaskIds `json:"warmuptasks" versions:"0-999"`
	// Identity of the streams instance that may have multiple consumers. Null if unchanged since last heartbeat.
	ProcessId *string `json:"processid" versions:"0-999"`
	// User-defined endpoint for Interactive Queries. Null if unchanged since last heartbeat, or if not defined on the client.
	UserEndpoint Endpoint `json:"userendpoint" versions:"0-999"`
	// Used for rack-aware assignment algorithm. Null if unchanged since last heartbeat.
	ClientTags []KeyValue `json:"clienttags" versions:"0-999"`
	// Cumulative changelog offsets for tasks. Only updated when a warm-up task has caught up, and according to the task offset interval. Null if unchanged since last heartbeat.
	TaskOffsets []TaskOffset `json:"taskoffsets" versions:"0-999"`
	// Cumulative changelog end-offsets for tasks. Only updated when a warm-up task has caught up, and according to the task offset interval. Null if unchanged since last heartbeat.
	TaskEndOffsets []TaskOffset `json:"taskendoffsets" versions:"0-999"`
	// Whether all Streams clients in the group should shut down.
	ShutdownApplication bool `json:"shutdownapplication" versions:"0-999"`
}

// Encode encodes a StreamsGroupHeartbeatRequest to a byte slice for the given version.
func (m *StreamsGroupHeartbeatRequest) Encode(version int16) ([]byte, error) {
	var buf bytes.Buffer
	if err := m.Write(&buf, version); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// Decode decodes a StreamsGroupHeartbeatRequest from a byte slice for the given version.
func (m *StreamsGroupHeartbeatRequest) Decode(data []byte, version int16) error {
	r := bytes.NewReader(data)
	return m.Read(r, version)
}

// Write writes a StreamsGroupHeartbeatRequest to an io.Writer for the given version.
func (m *StreamsGroupHeartbeatRequest) Write(w io.Writer, version int16) error {
	if version < 0 || version > 0 {
		return errors.New("unsupported version")
	}

	isFlexible := false
	if version >= 0 {
		isFlexible = true
	}

	// GroupId
	if version >= 0 && version <= 999 {
		if isFlexible {
			if err := protocol.WriteCompactString(w, m.GroupId); err != nil {
				return err
			}
		} else {
			if err := protocol.WriteString(w, m.GroupId); err != nil {
				return err
			}
		}
	}
	// MemberId
	if version >= 0 && version <= 999 {
		if isFlexible {
			if err := protocol.WriteCompactString(w, m.MemberId); err != nil {
				return err
			}
		} else {
			if err := protocol.WriteString(w, m.MemberId); err != nil {
				return err
			}
		}
	}
	// MemberEpoch
	if version >= 0 && version <= 999 {
		if err := protocol.WriteInt32(w, m.MemberEpoch); err != nil {
			return err
		}
	}
	// EndpointInformationEpoch
	if version >= 0 && version <= 999 {
		if err := protocol.WriteInt32(w, m.EndpointInformationEpoch); err != nil {
			return err
		}
	}
	// InstanceId
	if version >= 0 && version <= 999 {
		if isFlexible {
			if err := protocol.WriteCompactNullableString(w, m.InstanceId); err != nil {
				return err
			}
		} else {
			if err := protocol.WriteNullableString(w, m.InstanceId); err != nil {
				return err
			}
		}
	}
	// RackId
	if version >= 0 && version <= 999 {
		if isFlexible {
			if err := protocol.WriteCompactNullableString(w, m.RackId); err != nil {
				return err
			}
		} else {
			if err := protocol.WriteNullableString(w, m.RackId); err != nil {
				return err
			}
		}
	}
	// RebalanceTimeoutMs
	if version >= 0 && version <= 999 {
		if err := protocol.WriteInt32(w, m.RebalanceTimeoutMs); err != nil {
			return err
		}
	}
	// Topology
	if version >= 0 && version <= 999 {
		// Epoch
		if version >= 0 && version <= 999 {
			if err := protocol.WriteInt32(w, m.Topology.Epoch); err != nil {
				return err
			}
		}
		// Subtopologies
		if version >= 0 && version <= 999 {
			// Encode array using ArrayEncoder
			encoder := func(item interface{}) ([]byte, error) {
				if item == nil {
					return nil, nil
				}
				structItem, ok := item.(StreamsGroupHeartbeatRequestSubtopology)
				if !ok {
					return nil, errors.New("invalid type for array element")
				}
				var elemBuf bytes.Buffer
				// Temporarily use elemBuf as writer
				elemW := &elemBuf
				// SubtopologyId
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactString(elemW, structItem.SubtopologyId); err != nil {
							return nil, err
						}
					} else {
						if err := protocol.WriteString(elemW, structItem.SubtopologyId); err != nil {
							return nil, err
						}
					}
				}
				// SourceTopics
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactStringArray(elemW, structItem.SourceTopics); err != nil {
							return nil, err
						}
					} else {
						if err := protocol.WriteStringArray(elemW, structItem.SourceTopics); err != nil {
							return nil, err
						}
					}
				}
				// SourceTopicRegex
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactStringArray(elemW, structItem.SourceTopicRegex); err != nil {
							return nil, err
						}
					} else {
						if err := protocol.WriteStringArray(elemW, structItem.SourceTopicRegex); err != nil {
							return nil, err
						}
					}
				}
				// StateChangelogTopics
				if version >= 0 && version <= 999 {
					if isFlexible {
						length := uint32(len(structItem.StateChangelogTopics) + 1)
						if err := protocol.WriteVaruint32(elemW, length); err != nil {
							return nil, err
						}
					} else {
						if err := protocol.WriteInt32(elemW, int32(len(structItem.StateChangelogTopics))); err != nil {
							return nil, err
						}
					}
					for i := range structItem.StateChangelogTopics {
						// Name
						if version >= 0 && version <= 999 {
							if isFlexible {
								if err := protocol.WriteCompactString(elemW, structItem.StateChangelogTopics[i].Name); err != nil {
									return nil, err
								}
							} else {
								if err := protocol.WriteString(elemW, structItem.StateChangelogTopics[i].Name); err != nil {
									return nil, err
								}
							}
						}
						// Partitions
						if version >= 0 && version <= 999 {
							if err := protocol.WriteInt32(elemW, structItem.StateChangelogTopics[i].Partitions); err != nil {
								return nil, err
							}
						}
						// ReplicationFactor
						if version >= 0 && version <= 999 {
							if err := protocol.WriteInt16(elemW, structItem.StateChangelogTopics[i].ReplicationFactor); err != nil {
								return nil, err
							}
						}
						// TopicConfigs
						if version >= 0 && version <= 999 {
							if isFlexible {
								length := uint32(len(structItem.StateChangelogTopics[i].TopicConfigs) + 1)
								if err := protocol.WriteVaruint32(elemW, length); err != nil {
									return nil, err
								}
							} else {
								if err := protocol.WriteInt32(elemW, int32(len(structItem.StateChangelogTopics[i].TopicConfigs))); err != nil {
									return nil, err
								}
							}
							for i := range structItem.StateChangelogTopics[i].TopicConfigs {
								// Key
								if version >= 0 && version <= 999 {
									if isFlexible {
										if err := protocol.WriteCompactString(elemW, structItem.StateChangelogTopics[i].TopicConfigs[i].Key); err != nil {
											return nil, err
										}
									} else {
										if err := protocol.WriteString(elemW, structItem.StateChangelogTopics[i].TopicConfigs[i].Key); err != nil {
											return nil, err
										}
									}
								}
								// Value
								if version >= 0 && version <= 999 {
									if isFlexible {
										if err := protocol.WriteCompactString(elemW, structItem.StateChangelogTopics[i].TopicConfigs[i].Value); err != nil {
											return nil, err
										}
									} else {
										if err := protocol.WriteString(elemW, structItem.StateChangelogTopics[i].TopicConfigs[i].Value); err != nil {
											return nil, err
										}
									}
								}
							}
						}
					}
				}
				// RepartitionSinkTopics
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactStringArray(elemW, structItem.RepartitionSinkTopics); err != nil {
							return nil, err
						}
					} else {
						if err := protocol.WriteStringArray(elemW, structItem.RepartitionSinkTopics); err != nil {
							return nil, err
						}
					}
				}
				// RepartitionSourceTopics
				if version >= 0 && version <= 999 {
					if isFlexible {
						length := uint32(len(structItem.RepartitionSourceTopics) + 1)
						if err := protocol.WriteVaruint32(elemW, length); err != nil {
							return nil, err
						}
					} else {
						if err := protocol.WriteInt32(elemW, int32(len(structItem.RepartitionSourceTopics))); err != nil {
							return nil, err
						}
					}
					for i := range structItem.RepartitionSourceTopics {
						// Name
						if version >= 0 && version <= 999 {
							if isFlexible {
								if err := protocol.WriteCompactString(elemW, structItem.RepartitionSourceTopics[i].Name); err != nil {
									return nil, err
								}
							} else {
								if err := protocol.WriteString(elemW, structItem.RepartitionSourceTopics[i].Name); err != nil {
									return nil, err
								}
							}
						}
						// Partitions
						if version >= 0 && version <= 999 {
							if err := protocol.WriteInt32(elemW, structItem.RepartitionSourceTopics[i].Partitions); err != nil {
								return nil, err
							}
						}
						// ReplicationFactor
						if version >= 0 && version <= 999 {
							if err := protocol.WriteInt16(elemW, structItem.RepartitionSourceTopics[i].ReplicationFactor); err != nil {
								return nil, err
							}
						}
						// TopicConfigs
						if version >= 0 && version <= 999 {
							if isFlexible {
								length := uint32(len(structItem.RepartitionSourceTopics[i].TopicConfigs) + 1)
								if err := protocol.WriteVaruint32(elemW, length); err != nil {
									return nil, err
								}
							} else {
								if err := protocol.WriteInt32(elemW, int32(len(structItem.RepartitionSourceTopics[i].TopicConfigs))); err != nil {
									return nil, err
								}
							}
							for i := range structItem.RepartitionSourceTopics[i].TopicConfigs {
								// Key
								if version >= 0 && version <= 999 {
									if isFlexible {
										if err := protocol.WriteCompactString(elemW, structItem.RepartitionSourceTopics[i].TopicConfigs[i].Key); err != nil {
											return nil, err
										}
									} else {
										if err := protocol.WriteString(elemW, structItem.RepartitionSourceTopics[i].TopicConfigs[i].Key); err != nil {
											return nil, err
										}
									}
								}
								// Value
								if version >= 0 && version <= 999 {
									if isFlexible {
										if err := protocol.WriteCompactString(elemW, structItem.RepartitionSourceTopics[i].TopicConfigs[i].Value); err != nil {
											return nil, err
										}
									} else {
										if err := protocol.WriteString(elemW, structItem.RepartitionSourceTopics[i].TopicConfigs[i].Value); err != nil {
											return nil, err
										}
									}
								}
							}
						}
					}
				}
				// CopartitionGroups
				if version >= 0 && version <= 999 {
					if isFlexible {
						length := uint32(len(structItem.CopartitionGroups) + 1)
						if err := protocol.WriteVaruint32(elemW, length); err != nil {
							return nil, err
						}
					} else {
						if err := protocol.WriteInt32(elemW, int32(len(structItem.CopartitionGroups))); err != nil {
							return nil, err
						}
					}
					for i := range structItem.CopartitionGroups {
						// SourceTopics
						if version >= 0 && version <= 999 {
							if isFlexible {
								if err := protocol.WriteCompactInt16Array(elemW, structItem.CopartitionGroups[i].SourceTopics); err != nil {
									return nil, err
								}
							} else {
								if err := protocol.WriteInt16Array(elemW, structItem.CopartitionGroups[i].SourceTopics); err != nil {
									return nil, err
								}
							}
						}
						// SourceTopicRegex
						if version >= 0 && version <= 999 {
							if isFlexible {
								if err := protocol.WriteCompactInt16Array(elemW, structItem.CopartitionGroups[i].SourceTopicRegex); err != nil {
									return nil, err
								}
							} else {
								if err := protocol.WriteInt16Array(elemW, structItem.CopartitionGroups[i].SourceTopicRegex); err != nil {
									return nil, err
								}
							}
						}
						// RepartitionSourceTopics
						if version >= 0 && version <= 999 {
							if isFlexible {
								if err := protocol.WriteCompactInt16Array(elemW, structItem.CopartitionGroups[i].RepartitionSourceTopics); err != nil {
									return nil, err
								}
							} else {
								if err := protocol.WriteInt16Array(elemW, structItem.CopartitionGroups[i].RepartitionSourceTopics); err != nil {
									return nil, err
								}
							}
						}
					}
				}
				return elemBuf.Bytes(), nil
			}
			items := make([]interface{}, len(m.Topology.Subtopologies))
			for i := range m.Topology.Subtopologies {
				items[i] = m.Topology.Subtopologies[i]
			}
			if isFlexible {
				if err := protocol.WriteCompactArray(w, items, encoder); err != nil {
					return err
				}
			} else {
				if err := protocol.WriteArray(w, items, encoder); err != nil {
					return err
				}
			}
		}
		// Write tagged fields if flexible
		if isFlexible {
			if err := m.Topology.writeTaggedFields(w, version); err != nil {
				return err
			}
		}
	}
	// ActiveTasks
	if version >= 0 && version <= 999 {
		// Encode array using ArrayEncoder
		encoder := func(item interface{}) ([]byte, error) {
			if item == nil {
				return nil, nil
			}
			structItem, ok := item.(TaskIds)
			if !ok {
				return nil, errors.New("invalid type for array element")
			}
			var elemBuf bytes.Buffer
			// Temporarily use elemBuf as writer
			elemW := &elemBuf
			// SubtopologyId
			if version >= 0 && version <= 999 {
				if isFlexible {
					if err := protocol.WriteCompactString(elemW, structItem.SubtopologyId); err != nil {
						return nil, err
					}
				} else {
					if err := protocol.WriteString(elemW, structItem.SubtopologyId); err != nil {
						return nil, err
					}
				}
			}
			// Partitions
			if version >= 0 && version <= 999 {
				if isFlexible {
					if err := protocol.WriteCompactInt32Array(elemW, structItem.Partitions); err != nil {
						return nil, err
					}
				} else {
					if err := protocol.WriteInt32Array(elemW, structItem.Partitions); err != nil {
						return nil, err
					}
				}
			}
			// Write tagged fields if flexible
			if isFlexible {
				if err := structItem.writeTaggedFields(elemW, version); err != nil {
					return nil, err
				}
			}
			return elemBuf.Bytes(), nil
		}
		items := make([]interface{}, len(m.ActiveTasks))
		for i := range m.ActiveTasks {
			items[i] = m.ActiveTasks[i]
		}
		if m.ActiveTasks == nil {
			if isFlexible {
				if err := protocol.WriteVaruint32(w, 0); err != nil {
					return err
				}
			} else {
				if err := protocol.WriteInt32(w, -1); err != nil {
					return err
				}
			}
		} else {
			if isFlexible {
				if err := protocol.WriteCompactArray(w, items, encoder); err != nil {
					return err
				}
			} else {
				if err := protocol.WriteArray(w, items, encoder); err != nil {
					return err
				}
			}
		}
	}
	// StandbyTasks
	if version >= 0 && version <= 999 {
		// Encode array using ArrayEncoder
		encoder := func(item interface{}) ([]byte, error) {
			if item == nil {
				return nil, nil
			}
			structItem, ok := item.(TaskIds)
			if !ok {
				return nil, errors.New("invalid type for array element")
			}
			var elemBuf bytes.Buffer
			// Temporarily use elemBuf as writer
			elemW := &elemBuf
			// SubtopologyId
			if version >= 0 && version <= 999 {
				if isFlexible {
					if err := protocol.WriteCompactString(elemW, structItem.SubtopologyId); err != nil {
						return nil, err
					}
				} else {
					if err := protocol.WriteString(elemW, structItem.SubtopologyId); err != nil {
						return nil, err
					}
				}
			}
			// Partitions
			if version >= 0 && version <= 999 {
				if isFlexible {
					if err := protocol.WriteCompactInt32Array(elemW, structItem.Partitions); err != nil {
						return nil, err
					}
				} else {
					if err := protocol.WriteInt32Array(elemW, structItem.Partitions); err != nil {
						return nil, err
					}
				}
			}
			// Write tagged fields if flexible
			if isFlexible {
				if err := structItem.writeTaggedFields(elemW, version); err != nil {
					return nil, err
				}
			}
			return elemBuf.Bytes(), nil
		}
		items := make([]interface{}, len(m.StandbyTasks))
		for i := range m.StandbyTasks {
			items[i] = m.StandbyTasks[i]
		}
		if m.StandbyTasks == nil {
			if isFlexible {
				if err := protocol.WriteVaruint32(w, 0); err != nil {
					return err
				}
			} else {
				if err := protocol.WriteInt32(w, -1); err != nil {
					return err
				}
			}
		} else {
			if isFlexible {
				if err := protocol.WriteCompactArray(w, items, encoder); err != nil {
					return err
				}
			} else {
				if err := protocol.WriteArray(w, items, encoder); err != nil {
					return err
				}
			}
		}
	}
	// WarmupTasks
	if version >= 0 && version <= 999 {
		// Encode array using ArrayEncoder
		encoder := func(item interface{}) ([]byte, error) {
			if item == nil {
				return nil, nil
			}
			structItem, ok := item.(TaskIds)
			if !ok {
				return nil, errors.New("invalid type for array element")
			}
			var elemBuf bytes.Buffer
			// Temporarily use elemBuf as writer
			elemW := &elemBuf
			// SubtopologyId
			if version >= 0 && version <= 999 {
				if isFlexible {
					if err := protocol.WriteCompactString(elemW, structItem.SubtopologyId); err != nil {
						return nil, err
					}
				} else {
					if err := protocol.WriteString(elemW, structItem.SubtopologyId); err != nil {
						return nil, err
					}
				}
			}
			// Partitions
			if version >= 0 && version <= 999 {
				if isFlexible {
					if err := protocol.WriteCompactInt32Array(elemW, structItem.Partitions); err != nil {
						return nil, err
					}
				} else {
					if err := protocol.WriteInt32Array(elemW, structItem.Partitions); err != nil {
						return nil, err
					}
				}
			}
			// Write tagged fields if flexible
			if isFlexible {
				if err := structItem.writeTaggedFields(elemW, version); err != nil {
					return nil, err
				}
			}
			return elemBuf.Bytes(), nil
		}
		items := make([]interface{}, len(m.WarmupTasks))
		for i := range m.WarmupTasks {
			items[i] = m.WarmupTasks[i]
		}
		if m.WarmupTasks == nil {
			if isFlexible {
				if err := protocol.WriteVaruint32(w, 0); err != nil {
					return err
				}
			} else {
				if err := protocol.WriteInt32(w, -1); err != nil {
					return err
				}
			}
		} else {
			if isFlexible {
				if err := protocol.WriteCompactArray(w, items, encoder); err != nil {
					return err
				}
			} else {
				if err := protocol.WriteArray(w, items, encoder); err != nil {
					return err
				}
			}
		}
	}
	// ProcessId
	if version >= 0 && version <= 999 {
		if isFlexible {
			if err := protocol.WriteCompactNullableString(w, m.ProcessId); err != nil {
				return err
			}
		} else {
			if err := protocol.WriteNullableString(w, m.ProcessId); err != nil {
				return err
			}
		}
	}
	// UserEndpoint
	if version >= 0 && version <= 999 {
	}
	// ClientTags
	if version >= 0 && version <= 999 {
		// Encode array using ArrayEncoder
		encoder := func(item interface{}) ([]byte, error) {
			if item == nil {
				return nil, nil
			}
			structItem, ok := item.(KeyValue)
			if !ok {
				return nil, errors.New("invalid type for array element")
			}
			var elemBuf bytes.Buffer
			// Temporarily use elemBuf as writer
			elemW := &elemBuf
			// Key
			if version >= 0 && version <= 999 {
				if isFlexible {
					if err := protocol.WriteCompactString(elemW, structItem.Key); err != nil {
						return nil, err
					}
				} else {
					if err := protocol.WriteString(elemW, structItem.Key); err != nil {
						return nil, err
					}
				}
			}
			// Value
			if version >= 0 && version <= 999 {
				if isFlexible {
					if err := protocol.WriteCompactString(elemW, structItem.Value); err != nil {
						return nil, err
					}
				} else {
					if err := protocol.WriteString(elemW, structItem.Value); err != nil {
						return nil, err
					}
				}
			}
			// Write tagged fields if flexible
			if isFlexible {
				if err := structItem.writeTaggedFields(elemW, version); err != nil {
					return nil, err
				}
			}
			return elemBuf.Bytes(), nil
		}
		items := make([]interface{}, len(m.ClientTags))
		for i := range m.ClientTags {
			items[i] = m.ClientTags[i]
		}
		if m.ClientTags == nil {
			if isFlexible {
				if err := protocol.WriteVaruint32(w, 0); err != nil {
					return err
				}
			} else {
				if err := protocol.WriteInt32(w, -1); err != nil {
					return err
				}
			}
		} else {
			if isFlexible {
				if err := protocol.WriteCompactArray(w, items, encoder); err != nil {
					return err
				}
			} else {
				if err := protocol.WriteArray(w, items, encoder); err != nil {
					return err
				}
			}
		}
	}
	// TaskOffsets
	if version >= 0 && version <= 999 {
		// Encode array using ArrayEncoder
		encoder := func(item interface{}) ([]byte, error) {
			if item == nil {
				return nil, nil
			}
			structItem, ok := item.(TaskOffset)
			if !ok {
				return nil, errors.New("invalid type for array element")
			}
			var elemBuf bytes.Buffer
			// Temporarily use elemBuf as writer
			elemW := &elemBuf
			// SubtopologyId
			if version >= 0 && version <= 999 {
				if isFlexible {
					if err := protocol.WriteCompactString(elemW, structItem.SubtopologyId); err != nil {
						return nil, err
					}
				} else {
					if err := protocol.WriteString(elemW, structItem.SubtopologyId); err != nil {
						return nil, err
					}
				}
			}
			// Partition
			if version >= 0 && version <= 999 {
				if err := protocol.WriteInt32(elemW, structItem.Partition); err != nil {
					return nil, err
				}
			}
			// Offset
			if version >= 0 && version <= 999 {
				if err := protocol.WriteInt64(elemW, structItem.Offset); err != nil {
					return nil, err
				}
			}
			// Write tagged fields if flexible
			if isFlexible {
				if err := structItem.writeTaggedFields(elemW, version); err != nil {
					return nil, err
				}
			}
			return elemBuf.Bytes(), nil
		}
		items := make([]interface{}, len(m.TaskOffsets))
		for i := range m.TaskOffsets {
			items[i] = m.TaskOffsets[i]
		}
		if m.TaskOffsets == nil {
			if isFlexible {
				if err := protocol.WriteVaruint32(w, 0); err != nil {
					return err
				}
			} else {
				if err := protocol.WriteInt32(w, -1); err != nil {
					return err
				}
			}
		} else {
			if isFlexible {
				if err := protocol.WriteCompactArray(w, items, encoder); err != nil {
					return err
				}
			} else {
				if err := protocol.WriteArray(w, items, encoder); err != nil {
					return err
				}
			}
		}
	}
	// TaskEndOffsets
	if version >= 0 && version <= 999 {
		// Encode array using ArrayEncoder
		encoder := func(item interface{}) ([]byte, error) {
			if item == nil {
				return nil, nil
			}
			structItem, ok := item.(TaskOffset)
			if !ok {
				return nil, errors.New("invalid type for array element")
			}
			var elemBuf bytes.Buffer
			// Temporarily use elemBuf as writer
			elemW := &elemBuf
			// SubtopologyId
			if version >= 0 && version <= 999 {
				if isFlexible {
					if err := protocol.WriteCompactString(elemW, structItem.SubtopologyId); err != nil {
						return nil, err
					}
				} else {
					if err := protocol.WriteString(elemW, structItem.SubtopologyId); err != nil {
						return nil, err
					}
				}
			}
			// Partition
			if version >= 0 && version <= 999 {
				if err := protocol.WriteInt32(elemW, structItem.Partition); err != nil {
					return nil, err
				}
			}
			// Offset
			if version >= 0 && version <= 999 {
				if err := protocol.WriteInt64(elemW, structItem.Offset); err != nil {
					return nil, err
				}
			}
			// Write tagged fields if flexible
			if isFlexible {
				if err := structItem.writeTaggedFields(elemW, version); err != nil {
					return nil, err
				}
			}
			return elemBuf.Bytes(), nil
		}
		items := make([]interface{}, len(m.TaskEndOffsets))
		for i := range m.TaskEndOffsets {
			items[i] = m.TaskEndOffsets[i]
		}
		if m.TaskEndOffsets == nil {
			if isFlexible {
				if err := protocol.WriteVaruint32(w, 0); err != nil {
					return err
				}
			} else {
				if err := protocol.WriteInt32(w, -1); err != nil {
					return err
				}
			}
		} else {
			if isFlexible {
				if err := protocol.WriteCompactArray(w, items, encoder); err != nil {
					return err
				}
			} else {
				if err := protocol.WriteArray(w, items, encoder); err != nil {
					return err
				}
			}
		}
	}
	// ShutdownApplication
	if version >= 0 && version <= 999 {
		if err := protocol.WriteBool(w, m.ShutdownApplication); err != nil {
			return err
		}
	}
	// Write tagged fields if flexible
	if isFlexible {
		if err := m.writeTaggedFields(w, version); err != nil {
			return err
		}
	}
	return nil
}

// Read reads a StreamsGroupHeartbeatRequest from an io.Reader for the given version.
func (m *StreamsGroupHeartbeatRequest) Read(r io.Reader, version int16) error {
	if version < 0 || version > 0 {
		return errors.New("unsupported version")
	}

	isFlexible := false
	if version >= 0 {
		isFlexible = true
	}

	// GroupId
	if version >= 0 && version <= 999 {
		if isFlexible {
			val, err := protocol.ReadCompactString(r)
			if err != nil {
				return err
			}
			m.GroupId = val
		} else {
			val, err := protocol.ReadString(r)
			if err != nil {
				return err
			}
			m.GroupId = val
		}
	}
	// MemberId
	if version >= 0 && version <= 999 {
		if isFlexible {
			val, err := protocol.ReadCompactString(r)
			if err != nil {
				return err
			}
			m.MemberId = val
		} else {
			val, err := protocol.ReadString(r)
			if err != nil {
				return err
			}
			m.MemberId = val
		}
	}
	// MemberEpoch
	if version >= 0 && version <= 999 {
		val, err := protocol.ReadInt32(r)
		if err != nil {
			return err
		}
		m.MemberEpoch = val
	}
	// EndpointInformationEpoch
	if version >= 0 && version <= 999 {
		val, err := protocol.ReadInt32(r)
		if err != nil {
			return err
		}
		m.EndpointInformationEpoch = val
	}
	// InstanceId
	if version >= 0 && version <= 999 {
		if isFlexible {
			val, err := protocol.ReadCompactNullableString(r)
			if err != nil {
				return err
			}
			m.InstanceId = val
		} else {
			val, err := protocol.ReadNullableString(r)
			if err != nil {
				return err
			}
			m.InstanceId = val
		}
	}
	// RackId
	if version >= 0 && version <= 999 {
		if isFlexible {
			val, err := protocol.ReadCompactNullableString(r)
			if err != nil {
				return err
			}
			m.RackId = val
		} else {
			val, err := protocol.ReadNullableString(r)
			if err != nil {
				return err
			}
			m.RackId = val
		}
	}
	// RebalanceTimeoutMs
	if version >= 0 && version <= 999 {
		val, err := protocol.ReadInt32(r)
		if err != nil {
			return err
		}
		m.RebalanceTimeoutMs = val
	}
	// Topology
	if version >= 0 && version <= 999 {
		// Epoch
		if version >= 0 && version <= 999 {
			val, err := protocol.ReadInt32(r)
			if err != nil {
				return err
			}
			m.Topology.Epoch = val
		}
		// Subtopologies
		if version >= 0 && version <= 999 {
			// Decode array using ArrayDecoder
			decoder := func(data []byte) (interface{}, int, error) {
				var elem StreamsGroupHeartbeatRequestSubtopology
				elemR := bytes.NewReader(data)
				// SubtopologyId
				if version >= 0 && version <= 999 {
					if isFlexible {
						val, err := protocol.ReadCompactString(elemR)
						if err != nil {
							return nil, 0, err
						}
						elem.SubtopologyId = val
					} else {
						val, err := protocol.ReadString(elemR)
						if err != nil {
							return nil, 0, err
						}
						elem.SubtopologyId = val
					}
				}
				// SourceTopics
				if version >= 0 && version <= 999 {
					if isFlexible {
						val, err := protocol.ReadCompactStringArray(elemR)
						if err != nil {
							return nil, 0, err
						}
						elem.SourceTopics = val
					} else {
						val, err := protocol.ReadStringArray(elemR)
						if err != nil {
							return nil, 0, err
						}
						elem.SourceTopics = val
					}
				}
				// SourceTopicRegex
				if version >= 0 && version <= 999 {
					if isFlexible {
						val, err := protocol.ReadCompactStringArray(elemR)
						if err != nil {
							return nil, 0, err
						}
						elem.SourceTopicRegex = val
					} else {
						val, err := protocol.ReadStringArray(elemR)
						if err != nil {
							return nil, 0, err
						}
						elem.SourceTopicRegex = val
					}
				}
				// StateChangelogTopics
				if version >= 0 && version <= 999 {
					// Nested array in decoder - manual handling needed
					return nil, 0, errors.New("nested arrays in decoder not fully supported")
				}
				// RepartitionSinkTopics
				if version >= 0 && version <= 999 {
					if isFlexible {
						val, err := protocol.ReadCompactStringArray(elemR)
						if err != nil {
							return nil, 0, err
						}
						elem.RepartitionSinkTopics = val
					} else {
						val, err := protocol.ReadStringArray(elemR)
						if err != nil {
							return nil, 0, err
						}
						elem.RepartitionSinkTopics = val
					}
				}
				// RepartitionSourceTopics
				if version >= 0 && version <= 999 {
					// Nested array in decoder - manual handling needed
					return nil, 0, errors.New("nested arrays in decoder not fully supported")
				}
				// CopartitionGroups
				if version >= 0 && version <= 999 {
					// Nested array in decoder - manual handling needed
					return nil, 0, errors.New("nested arrays in decoder not fully supported")
				}
				consumed := len(data) - elemR.Len()
				return elem, consumed, nil
			}
			if isFlexible {
				lengthUint, err := protocol.ReadVaruint32(r)
				if err != nil {
					return err
				}
				if lengthUint < 1 {
					return errors.New("invalid compact array length")
				}
				length := int32(lengthUint - 1)
				// Collect all array elements into a buffer
				var arrayBuf bytes.Buffer
				for i := int32(0); i < length; i++ {
					// Read element into struct and encode to buffer
					var elemBuf bytes.Buffer
					elemW := &elemBuf
					var tempElem StreamsGroupHeartbeatRequestSubtopology
					// SubtopologyId
					if version >= 0 && version <= 999 {
						if isFlexible {
							val, err := protocol.ReadCompactString(r)
							if err != nil {
								return err
							}
							tempElem.SubtopologyId = val
						} else {
							val, err := protocol.ReadString(r)
							if err != nil {
								return err
							}
							tempElem.SubtopologyId = val
						}
					}
					// SourceTopics
					if version >= 0 && version <= 999 {
						if isFlexible {
							val, err := protocol.ReadCompactStringArray(r)
							if err != nil {
								return err
							}
							tempElem.SourceTopics = val
						} else {
							val, err := protocol.ReadStringArray(r)
							if err != nil {
								return err
							}
							tempElem.SourceTopics = val
						}
					}
					// SourceTopicRegex
					if version >= 0 && version <= 999 {
						if isFlexible {
							val, err := protocol.ReadCompactStringArray(r)
							if err != nil {
								return err
							}
							tempElem.SourceTopicRegex = val
						} else {
							val, err := protocol.ReadStringArray(r)
							if err != nil {
								return err
							}
							tempElem.SourceTopicRegex = val
						}
					}
					// StateChangelogTopics
					if version >= 0 && version <= 999 {
						// Decode array using ArrayDecoder
						decoder := func(data []byte) (interface{}, int, error) {
							var elem TopicInfo
							elemR := bytes.NewReader(data)
							// Name
							if version >= 0 && version <= 999 {
								if isFlexible {
									val, err := protocol.ReadCompactString(elemR)
									if err != nil {
										return nil, 0, err
									}
									elem.Name = val
								} else {
									val, err := protocol.ReadString(elemR)
									if err != nil {
										return nil, 0, err
									}
									elem.Name = val
								}
							}
							// Partitions
							if version >= 0 && version <= 999 {
								val, err := protocol.ReadInt32(elemR)
								if err != nil {
									return nil, 0, err
								}
								elem.Partitions = val
							}
							// ReplicationFactor
							if version >= 0 && version <= 999 {
								val, err := protocol.ReadInt16(elemR)
								if err != nil {
									return nil, 0, err
								}
								elem.ReplicationFactor = val
							}
							// TopicConfigs
							if version >= 0 && version <= 999 {
								// Nested array in decoder - manual handling needed
								return nil, 0, errors.New("nested arrays in decoder not fully supported")
							}
							consumed := len(data) - elemR.Len()
							return elem, consumed, nil
						}
						if isFlexible {
							lengthUint, err := protocol.ReadVaruint32(r)
							if err != nil {
								return err
							}
							if lengthUint < 1 {
								return errors.New("invalid compact array length")
							}
							length := int32(lengthUint - 1)
							// Collect all array elements into a buffer
							var arrayBuf bytes.Buffer
							for i := int32(0); i < length; i++ {
								// Read element into struct and encode to buffer
								var elemBuf bytes.Buffer
								elemW := &elemBuf
								var tempElem TopicInfo
								// Name
								if version >= 0 && version <= 999 {
									if isFlexible {
										val, err := protocol.ReadCompactString(r)
										if err != nil {
											return err
										}
										tempElem.Name = val
									} else {
										val, err := protocol.ReadString(r)
										if err != nil {
											return err
										}
										tempElem.Name = val
									}
								}
								// Partitions
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt32(r)
									if err != nil {
										return err
									}
									tempElem.Partitions = val
								}
								// ReplicationFactor
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt16(r)
									if err != nil {
										return err
									}
									tempElem.ReplicationFactor = val
								}
								// TopicConfigs
								if version >= 0 && version <= 999 {
									// Decode array using ArrayDecoder
									decoder := func(data []byte) (interface{}, int, error) {
										var elem KeyValue
										elemR := bytes.NewReader(data)
										// Key
										if version >= 0 && version <= 999 {
											if isFlexible {
												val, err := protocol.ReadCompactString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Key = val
											} else {
												val, err := protocol.ReadString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Key = val
											}
										}
										// Value
										if version >= 0 && version <= 999 {
											if isFlexible {
												val, err := protocol.ReadCompactString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Value = val
											} else {
												val, err := protocol.ReadString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Value = val
											}
										}
										consumed := len(data) - elemR.Len()
										return elem, consumed, nil
									}
									if isFlexible {
										lengthUint, err := protocol.ReadVaruint32(r)
										if err != nil {
											return err
										}
										if lengthUint < 1 {
											return errors.New("invalid compact array length")
										}
										length := int32(lengthUint - 1)
										// Collect all array elements into a buffer
										var arrayBuf bytes.Buffer
										for i := int32(0); i < length; i++ {
											// Read element into struct and encode to buffer
											var elemBuf bytes.Buffer
											elemW := &elemBuf
											var tempElem KeyValue
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												}
											}
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Key); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Key); err != nil {
														return err
													}
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Value); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Value); err != nil {
														return err
													}
												}
											}
											// Append to array buffer
											arrayBuf.Write(elemBuf.Bytes())
										}
										// Prepend length and decode using DecodeCompactArray
										lengthBytes := protocol.EncodeVaruint32(lengthUint)
										fullData := append(lengthBytes, arrayBuf.Bytes()...)
										decoded, _, err := protocol.DecodeCompactArray(fullData, decoder)
										if err != nil {
											return err
										}
										// Convert []interface{} to typed slice
										tempElem.TopicConfigs = make([]KeyValue, len(decoded))
										for i, item := range decoded {
											tempElem.TopicConfigs[i] = item.(KeyValue)
										}
									} else {
										length, err := protocol.ReadInt32(r)
										if err != nil {
											return err
										}
										// Collect all array elements into a buffer
										var arrayBuf bytes.Buffer
										for i := int32(0); i < length; i++ {
											// Read element into struct and encode to buffer
											var elemBuf bytes.Buffer
											elemW := &elemBuf
											var tempElem KeyValue
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												}
											}
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Key); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Key); err != nil {
														return err
													}
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Value); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Value); err != nil {
														return err
													}
												}
											}
											// Append to array buffer
											arrayBuf.Write(elemBuf.Bytes())
										}
										// Prepend length and decode using DecodeArray
										lengthBytes := protocol.EncodeInt32(length)
										fullData := append(lengthBytes, arrayBuf.Bytes()...)
										decoded, _, err := protocol.DecodeArray(fullData, decoder)
										if err != nil {
											return err
										}
										// Convert []interface{} to typed slice
										tempElem.TopicConfigs = make([]KeyValue, len(decoded))
										for i, item := range decoded {
											tempElem.TopicConfigs[i] = item.(KeyValue)
										}
									}
								}
								// Name
								if version >= 0 && version <= 999 {
									if isFlexible {
										if err := protocol.WriteCompactString(elemW, tempElem.Name); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteString(elemW, tempElem.Name); err != nil {
											return err
										}
									}
								}
								// Partitions
								if version >= 0 && version <= 999 {
									if err := protocol.WriteInt32(elemW, tempElem.Partitions); err != nil {
										return err
									}
								}
								// ReplicationFactor
								if version >= 0 && version <= 999 {
									if err := protocol.WriteInt16(elemW, tempElem.ReplicationFactor); err != nil {
										return err
									}
								}
								// TopicConfigs
								if version >= 0 && version <= 999 {
									if isFlexible {
										length := uint32(len(tempElem.TopicConfigs) + 1)
										if err := protocol.WriteVaruint32(elemW, length); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteInt32(elemW, int32(len(tempElem.TopicConfigs))); err != nil {
											return err
										}
									}
									for i := range tempElem.TopicConfigs {
										// Key
										if version >= 0 && version <= 999 {
											if isFlexible {
												if err := protocol.WriteCompactString(elemW, tempElem.TopicConfigs[i].Key); err != nil {
													return err
												}
											} else {
												if err := protocol.WriteString(elemW, tempElem.TopicConfigs[i].Key); err != nil {
													return err
												}
											}
										}
										// Value
										if version >= 0 && version <= 999 {
											if isFlexible {
												if err := protocol.WriteCompactString(elemW, tempElem.TopicConfigs[i].Value); err != nil {
													return err
												}
											} else {
												if err := protocol.WriteString(elemW, tempElem.TopicConfigs[i].Value); err != nil {
													return err
												}
											}
										}
									}
								}
								// Append to array buffer
								arrayBuf.Write(elemBuf.Bytes())
							}
							// Prepend length and decode using DecodeCompactArray
							lengthBytes := protocol.EncodeVaruint32(lengthUint)
							fullData := append(lengthBytes, arrayBuf.Bytes()...)
							decoded, _, err := protocol.DecodeCompactArray(fullData, decoder)
							if err != nil {
								return err
							}
							// Convert []interface{} to typed slice
							tempElem.StateChangelogTopics = make([]TopicInfo, len(decoded))
							for i, item := range decoded {
								tempElem.StateChangelogTopics[i] = item.(TopicInfo)
							}
						} else {
							length, err := protocol.ReadInt32(r)
							if err != nil {
								return err
							}
							// Collect all array elements into a buffer
							var arrayBuf bytes.Buffer
							for i := int32(0); i < length; i++ {
								// Read element into struct and encode to buffer
								var elemBuf bytes.Buffer
								elemW := &elemBuf
								var tempElem TopicInfo
								// Name
								if version >= 0 && version <= 999 {
									if isFlexible {
										val, err := protocol.ReadCompactString(r)
										if err != nil {
											return err
										}
										tempElem.Name = val
									} else {
										val, err := protocol.ReadString(r)
										if err != nil {
											return err
										}
										tempElem.Name = val
									}
								}
								// Partitions
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt32(r)
									if err != nil {
										return err
									}
									tempElem.Partitions = val
								}
								// ReplicationFactor
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt16(r)
									if err != nil {
										return err
									}
									tempElem.ReplicationFactor = val
								}
								// TopicConfigs
								if version >= 0 && version <= 999 {
									// Decode array using ArrayDecoder
									decoder := func(data []byte) (interface{}, int, error) {
										var elem KeyValue
										elemR := bytes.NewReader(data)
										// Key
										if version >= 0 && version <= 999 {
											if isFlexible {
												val, err := protocol.ReadCompactString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Key = val
											} else {
												val, err := protocol.ReadString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Key = val
											}
										}
										// Value
										if version >= 0 && version <= 999 {
											if isFlexible {
												val, err := protocol.ReadCompactString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Value = val
											} else {
												val, err := protocol.ReadString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Value = val
											}
										}
										consumed := len(data) - elemR.Len()
										return elem, consumed, nil
									}
									if isFlexible {
										lengthUint, err := protocol.ReadVaruint32(r)
										if err != nil {
											return err
										}
										if lengthUint < 1 {
											return errors.New("invalid compact array length")
										}
										length := int32(lengthUint - 1)
										// Collect all array elements into a buffer
										var arrayBuf bytes.Buffer
										for i := int32(0); i < length; i++ {
											// Read element into struct and encode to buffer
											var elemBuf bytes.Buffer
											elemW := &elemBuf
											var tempElem KeyValue
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												}
											}
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Key); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Key); err != nil {
														return err
													}
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Value); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Value); err != nil {
														return err
													}
												}
											}
											// Append to array buffer
											arrayBuf.Write(elemBuf.Bytes())
										}
										// Prepend length and decode using DecodeCompactArray
										lengthBytes := protocol.EncodeVaruint32(lengthUint)
										fullData := append(lengthBytes, arrayBuf.Bytes()...)
										decoded, _, err := protocol.DecodeCompactArray(fullData, decoder)
										if err != nil {
											return err
										}
										// Convert []interface{} to typed slice
										tempElem.TopicConfigs = make([]KeyValue, len(decoded))
										for i, item := range decoded {
											tempElem.TopicConfigs[i] = item.(KeyValue)
										}
									} else {
										length, err := protocol.ReadInt32(r)
										if err != nil {
											return err
										}
										// Collect all array elements into a buffer
										var arrayBuf bytes.Buffer
										for i := int32(0); i < length; i++ {
											// Read element into struct and encode to buffer
											var elemBuf bytes.Buffer
											elemW := &elemBuf
											var tempElem KeyValue
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												}
											}
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Key); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Key); err != nil {
														return err
													}
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Value); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Value); err != nil {
														return err
													}
												}
											}
											// Append to array buffer
											arrayBuf.Write(elemBuf.Bytes())
										}
										// Prepend length and decode using DecodeArray
										lengthBytes := protocol.EncodeInt32(length)
										fullData := append(lengthBytes, arrayBuf.Bytes()...)
										decoded, _, err := protocol.DecodeArray(fullData, decoder)
										if err != nil {
											return err
										}
										// Convert []interface{} to typed slice
										tempElem.TopicConfigs = make([]KeyValue, len(decoded))
										for i, item := range decoded {
											tempElem.TopicConfigs[i] = item.(KeyValue)
										}
									}
								}
								// Name
								if version >= 0 && version <= 999 {
									if isFlexible {
										if err := protocol.WriteCompactString(elemW, tempElem.Name); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteString(elemW, tempElem.Name); err != nil {
											return err
										}
									}
								}
								// Partitions
								if version >= 0 && version <= 999 {
									if err := protocol.WriteInt32(elemW, tempElem.Partitions); err != nil {
										return err
									}
								}
								// ReplicationFactor
								if version >= 0 && version <= 999 {
									if err := protocol.WriteInt16(elemW, tempElem.ReplicationFactor); err != nil {
										return err
									}
								}
								// TopicConfigs
								if version >= 0 && version <= 999 {
									if isFlexible {
										length := uint32(len(tempElem.TopicConfigs) + 1)
										if err := protocol.WriteVaruint32(elemW, length); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteInt32(elemW, int32(len(tempElem.TopicConfigs))); err != nil {
											return err
										}
									}
									for i := range tempElem.TopicConfigs {
										// Key
										if version >= 0 && version <= 999 {
											if isFlexible {
												if err := protocol.WriteCompactString(elemW, tempElem.TopicConfigs[i].Key); err != nil {
													return err
												}
											} else {
												if err := protocol.WriteString(elemW, tempElem.TopicConfigs[i].Key); err != nil {
													return err
												}
											}
										}
										// Value
										if version >= 0 && version <= 999 {
											if isFlexible {
												if err := protocol.WriteCompactString(elemW, tempElem.TopicConfigs[i].Value); err != nil {
													return err
												}
											} else {
												if err := protocol.WriteString(elemW, tempElem.TopicConfigs[i].Value); err != nil {
													return err
												}
											}
										}
									}
								}
								// Append to array buffer
								arrayBuf.Write(elemBuf.Bytes())
							}
							// Prepend length and decode using DecodeArray
							lengthBytes := protocol.EncodeInt32(length)
							fullData := append(lengthBytes, arrayBuf.Bytes()...)
							decoded, _, err := protocol.DecodeArray(fullData, decoder)
							if err != nil {
								return err
							}
							// Convert []interface{} to typed slice
							tempElem.StateChangelogTopics = make([]TopicInfo, len(decoded))
							for i, item := range decoded {
								tempElem.StateChangelogTopics[i] = item.(TopicInfo)
							}
						}
					}
					// RepartitionSinkTopics
					if version >= 0 && version <= 999 {
						if isFlexible {
							val, err := protocol.ReadCompactStringArray(r)
							if err != nil {
								return err
							}
							tempElem.RepartitionSinkTopics = val
						} else {
							val, err := protocol.ReadStringArray(r)
							if err != nil {
								return err
							}
							tempElem.RepartitionSinkTopics = val
						}
					}
					// RepartitionSourceTopics
					if version >= 0 && version <= 999 {
						// Decode array using ArrayDecoder
						decoder := func(data []byte) (interface{}, int, error) {
							var elem TopicInfo
							elemR := bytes.NewReader(data)
							// Name
							if version >= 0 && version <= 999 {
								if isFlexible {
									val, err := protocol.ReadCompactString(elemR)
									if err != nil {
										return nil, 0, err
									}
									elem.Name = val
								} else {
									val, err := protocol.ReadString(elemR)
									if err != nil {
										return nil, 0, err
									}
									elem.Name = val
								}
							}
							// Partitions
							if version >= 0 && version <= 999 {
								val, err := protocol.ReadInt32(elemR)
								if err != nil {
									return nil, 0, err
								}
								elem.Partitions = val
							}
							// ReplicationFactor
							if version >= 0 && version <= 999 {
								val, err := protocol.ReadInt16(elemR)
								if err != nil {
									return nil, 0, err
								}
								elem.ReplicationFactor = val
							}
							// TopicConfigs
							if version >= 0 && version <= 999 {
								// Nested array in decoder - manual handling needed
								return nil, 0, errors.New("nested arrays in decoder not fully supported")
							}
							consumed := len(data) - elemR.Len()
							return elem, consumed, nil
						}
						if isFlexible {
							lengthUint, err := protocol.ReadVaruint32(r)
							if err != nil {
								return err
							}
							if lengthUint < 1 {
								return errors.New("invalid compact array length")
							}
							length := int32(lengthUint - 1)
							// Collect all array elements into a buffer
							var arrayBuf bytes.Buffer
							for i := int32(0); i < length; i++ {
								// Read element into struct and encode to buffer
								var elemBuf bytes.Buffer
								elemW := &elemBuf
								var tempElem TopicInfo
								// Name
								if version >= 0 && version <= 999 {
									if isFlexible {
										val, err := protocol.ReadCompactString(r)
										if err != nil {
											return err
										}
										tempElem.Name = val
									} else {
										val, err := protocol.ReadString(r)
										if err != nil {
											return err
										}
										tempElem.Name = val
									}
								}
								// Partitions
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt32(r)
									if err != nil {
										return err
									}
									tempElem.Partitions = val
								}
								// ReplicationFactor
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt16(r)
									if err != nil {
										return err
									}
									tempElem.ReplicationFactor = val
								}
								// TopicConfigs
								if version >= 0 && version <= 999 {
									// Decode array using ArrayDecoder
									decoder := func(data []byte) (interface{}, int, error) {
										var elem KeyValue
										elemR := bytes.NewReader(data)
										// Key
										if version >= 0 && version <= 999 {
											if isFlexible {
												val, err := protocol.ReadCompactString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Key = val
											} else {
												val, err := protocol.ReadString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Key = val
											}
										}
										// Value
										if version >= 0 && version <= 999 {
											if isFlexible {
												val, err := protocol.ReadCompactString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Value = val
											} else {
												val, err := protocol.ReadString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Value = val
											}
										}
										consumed := len(data) - elemR.Len()
										return elem, consumed, nil
									}
									if isFlexible {
										lengthUint, err := protocol.ReadVaruint32(r)
										if err != nil {
											return err
										}
										if lengthUint < 1 {
											return errors.New("invalid compact array length")
										}
										length := int32(lengthUint - 1)
										// Collect all array elements into a buffer
										var arrayBuf bytes.Buffer
										for i := int32(0); i < length; i++ {
											// Read element into struct and encode to buffer
											var elemBuf bytes.Buffer
											elemW := &elemBuf
											var tempElem KeyValue
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												}
											}
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Key); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Key); err != nil {
														return err
													}
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Value); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Value); err != nil {
														return err
													}
												}
											}
											// Append to array buffer
											arrayBuf.Write(elemBuf.Bytes())
										}
										// Prepend length and decode using DecodeCompactArray
										lengthBytes := protocol.EncodeVaruint32(lengthUint)
										fullData := append(lengthBytes, arrayBuf.Bytes()...)
										decoded, _, err := protocol.DecodeCompactArray(fullData, decoder)
										if err != nil {
											return err
										}
										// Convert []interface{} to typed slice
										tempElem.TopicConfigs = make([]KeyValue, len(decoded))
										for i, item := range decoded {
											tempElem.TopicConfigs[i] = item.(KeyValue)
										}
									} else {
										length, err := protocol.ReadInt32(r)
										if err != nil {
											return err
										}
										// Collect all array elements into a buffer
										var arrayBuf bytes.Buffer
										for i := int32(0); i < length; i++ {
											// Read element into struct and encode to buffer
											var elemBuf bytes.Buffer
											elemW := &elemBuf
											var tempElem KeyValue
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												}
											}
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Key); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Key); err != nil {
														return err
													}
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Value); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Value); err != nil {
														return err
													}
												}
											}
											// Append to array buffer
											arrayBuf.Write(elemBuf.Bytes())
										}
										// Prepend length and decode using DecodeArray
										lengthBytes := protocol.EncodeInt32(length)
										fullData := append(lengthBytes, arrayBuf.Bytes()...)
										decoded, _, err := protocol.DecodeArray(fullData, decoder)
										if err != nil {
											return err
										}
										// Convert []interface{} to typed slice
										tempElem.TopicConfigs = make([]KeyValue, len(decoded))
										for i, item := range decoded {
											tempElem.TopicConfigs[i] = item.(KeyValue)
										}
									}
								}
								// Name
								if version >= 0 && version <= 999 {
									if isFlexible {
										if err := protocol.WriteCompactString(elemW, tempElem.Name); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteString(elemW, tempElem.Name); err != nil {
											return err
										}
									}
								}
								// Partitions
								if version >= 0 && version <= 999 {
									if err := protocol.WriteInt32(elemW, tempElem.Partitions); err != nil {
										return err
									}
								}
								// ReplicationFactor
								if version >= 0 && version <= 999 {
									if err := protocol.WriteInt16(elemW, tempElem.ReplicationFactor); err != nil {
										return err
									}
								}
								// TopicConfigs
								if version >= 0 && version <= 999 {
									if isFlexible {
										length := uint32(len(tempElem.TopicConfigs) + 1)
										if err := protocol.WriteVaruint32(elemW, length); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteInt32(elemW, int32(len(tempElem.TopicConfigs))); err != nil {
											return err
										}
									}
									for i := range tempElem.TopicConfigs {
										// Key
										if version >= 0 && version <= 999 {
											if isFlexible {
												if err := protocol.WriteCompactString(elemW, tempElem.TopicConfigs[i].Key); err != nil {
													return err
												}
											} else {
												if err := protocol.WriteString(elemW, tempElem.TopicConfigs[i].Key); err != nil {
													return err
												}
											}
										}
										// Value
										if version >= 0 && version <= 999 {
											if isFlexible {
												if err := protocol.WriteCompactString(elemW, tempElem.TopicConfigs[i].Value); err != nil {
													return err
												}
											} else {
												if err := protocol.WriteString(elemW, tempElem.TopicConfigs[i].Value); err != nil {
													return err
												}
											}
										}
									}
								}
								// Append to array buffer
								arrayBuf.Write(elemBuf.Bytes())
							}
							// Prepend length and decode using DecodeCompactArray
							lengthBytes := protocol.EncodeVaruint32(lengthUint)
							fullData := append(lengthBytes, arrayBuf.Bytes()...)
							decoded, _, err := protocol.DecodeCompactArray(fullData, decoder)
							if err != nil {
								return err
							}
							// Convert []interface{} to typed slice
							tempElem.RepartitionSourceTopics = make([]TopicInfo, len(decoded))
							for i, item := range decoded {
								tempElem.RepartitionSourceTopics[i] = item.(TopicInfo)
							}
						} else {
							length, err := protocol.ReadInt32(r)
							if err != nil {
								return err
							}
							// Collect all array elements into a buffer
							var arrayBuf bytes.Buffer
							for i := int32(0); i < length; i++ {
								// Read element into struct and encode to buffer
								var elemBuf bytes.Buffer
								elemW := &elemBuf
								var tempElem TopicInfo
								// Name
								if version >= 0 && version <= 999 {
									if isFlexible {
										val, err := protocol.ReadCompactString(r)
										if err != nil {
											return err
										}
										tempElem.Name = val
									} else {
										val, err := protocol.ReadString(r)
										if err != nil {
											return err
										}
										tempElem.Name = val
									}
								}
								// Partitions
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt32(r)
									if err != nil {
										return err
									}
									tempElem.Partitions = val
								}
								// ReplicationFactor
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt16(r)
									if err != nil {
										return err
									}
									tempElem.ReplicationFactor = val
								}
								// TopicConfigs
								if version >= 0 && version <= 999 {
									// Decode array using ArrayDecoder
									decoder := func(data []byte) (interface{}, int, error) {
										var elem KeyValue
										elemR := bytes.NewReader(data)
										// Key
										if version >= 0 && version <= 999 {
											if isFlexible {
												val, err := protocol.ReadCompactString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Key = val
											} else {
												val, err := protocol.ReadString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Key = val
											}
										}
										// Value
										if version >= 0 && version <= 999 {
											if isFlexible {
												val, err := protocol.ReadCompactString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Value = val
											} else {
												val, err := protocol.ReadString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Value = val
											}
										}
										consumed := len(data) - elemR.Len()
										return elem, consumed, nil
									}
									if isFlexible {
										lengthUint, err := protocol.ReadVaruint32(r)
										if err != nil {
											return err
										}
										if lengthUint < 1 {
											return errors.New("invalid compact array length")
										}
										length := int32(lengthUint - 1)
										// Collect all array elements into a buffer
										var arrayBuf bytes.Buffer
										for i := int32(0); i < length; i++ {
											// Read element into struct and encode to buffer
											var elemBuf bytes.Buffer
											elemW := &elemBuf
											var tempElem KeyValue
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												}
											}
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Key); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Key); err != nil {
														return err
													}
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Value); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Value); err != nil {
														return err
													}
												}
											}
											// Append to array buffer
											arrayBuf.Write(elemBuf.Bytes())
										}
										// Prepend length and decode using DecodeCompactArray
										lengthBytes := protocol.EncodeVaruint32(lengthUint)
										fullData := append(lengthBytes, arrayBuf.Bytes()...)
										decoded, _, err := protocol.DecodeCompactArray(fullData, decoder)
										if err != nil {
											return err
										}
										// Convert []interface{} to typed slice
										tempElem.TopicConfigs = make([]KeyValue, len(decoded))
										for i, item := range decoded {
											tempElem.TopicConfigs[i] = item.(KeyValue)
										}
									} else {
										length, err := protocol.ReadInt32(r)
										if err != nil {
											return err
										}
										// Collect all array elements into a buffer
										var arrayBuf bytes.Buffer
										for i := int32(0); i < length; i++ {
											// Read element into struct and encode to buffer
											var elemBuf bytes.Buffer
											elemW := &elemBuf
											var tempElem KeyValue
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												}
											}
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Key); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Key); err != nil {
														return err
													}
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Value); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Value); err != nil {
														return err
													}
												}
											}
											// Append to array buffer
											arrayBuf.Write(elemBuf.Bytes())
										}
										// Prepend length and decode using DecodeArray
										lengthBytes := protocol.EncodeInt32(length)
										fullData := append(lengthBytes, arrayBuf.Bytes()...)
										decoded, _, err := protocol.DecodeArray(fullData, decoder)
										if err != nil {
											return err
										}
										// Convert []interface{} to typed slice
										tempElem.TopicConfigs = make([]KeyValue, len(decoded))
										for i, item := range decoded {
											tempElem.TopicConfigs[i] = item.(KeyValue)
										}
									}
								}
								// Name
								if version >= 0 && version <= 999 {
									if isFlexible {
										if err := protocol.WriteCompactString(elemW, tempElem.Name); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteString(elemW, tempElem.Name); err != nil {
											return err
										}
									}
								}
								// Partitions
								if version >= 0 && version <= 999 {
									if err := protocol.WriteInt32(elemW, tempElem.Partitions); err != nil {
										return err
									}
								}
								// ReplicationFactor
								if version >= 0 && version <= 999 {
									if err := protocol.WriteInt16(elemW, tempElem.ReplicationFactor); err != nil {
										return err
									}
								}
								// TopicConfigs
								if version >= 0 && version <= 999 {
									if isFlexible {
										length := uint32(len(tempElem.TopicConfigs) + 1)
										if err := protocol.WriteVaruint32(elemW, length); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteInt32(elemW, int32(len(tempElem.TopicConfigs))); err != nil {
											return err
										}
									}
									for i := range tempElem.TopicConfigs {
										// Key
										if version >= 0 && version <= 999 {
											if isFlexible {
												if err := protocol.WriteCompactString(elemW, tempElem.TopicConfigs[i].Key); err != nil {
													return err
												}
											} else {
												if err := protocol.WriteString(elemW, tempElem.TopicConfigs[i].Key); err != nil {
													return err
												}
											}
										}
										// Value
										if version >= 0 && version <= 999 {
											if isFlexible {
												if err := protocol.WriteCompactString(elemW, tempElem.TopicConfigs[i].Value); err != nil {
													return err
												}
											} else {
												if err := protocol.WriteString(elemW, tempElem.TopicConfigs[i].Value); err != nil {
													return err
												}
											}
										}
									}
								}
								// Append to array buffer
								arrayBuf.Write(elemBuf.Bytes())
							}
							// Prepend length and decode using DecodeArray
							lengthBytes := protocol.EncodeInt32(length)
							fullData := append(lengthBytes, arrayBuf.Bytes()...)
							decoded, _, err := protocol.DecodeArray(fullData, decoder)
							if err != nil {
								return err
							}
							// Convert []interface{} to typed slice
							tempElem.RepartitionSourceTopics = make([]TopicInfo, len(decoded))
							for i, item := range decoded {
								tempElem.RepartitionSourceTopics[i] = item.(TopicInfo)
							}
						}
					}
					// CopartitionGroups
					if version >= 0 && version <= 999 {
						// Decode array using ArrayDecoder
						decoder := func(data []byte) (interface{}, int, error) {
							var elem StreamsGroupHeartbeatRequestCopartitionGroup
							elemR := bytes.NewReader(data)
							// SourceTopics
							if version >= 0 && version <= 999 {
								if isFlexible {
									val, err := protocol.ReadCompactInt16Array(elemR)
									if err != nil {
										return nil, 0, err
									}
									elem.SourceTopics = val
								} else {
									val, err := protocol.ReadInt16Array(elemR)
									if err != nil {
										return nil, 0, err
									}
									elem.SourceTopics = val
								}
							}
							// SourceTopicRegex
							if version >= 0 && version <= 999 {
								if isFlexible {
									val, err := protocol.ReadCompactInt16Array(elemR)
									if err != nil {
										return nil, 0, err
									}
									elem.SourceTopicRegex = val
								} else {
									val, err := protocol.ReadInt16Array(elemR)
									if err != nil {
										return nil, 0, err
									}
									elem.SourceTopicRegex = val
								}
							}
							// RepartitionSourceTopics
							if version >= 0 && version <= 999 {
								if isFlexible {
									val, err := protocol.ReadCompactInt16Array(elemR)
									if err != nil {
										return nil, 0, err
									}
									elem.RepartitionSourceTopics = val
								} else {
									val, err := protocol.ReadInt16Array(elemR)
									if err != nil {
										return nil, 0, err
									}
									elem.RepartitionSourceTopics = val
								}
							}
							consumed := len(data) - elemR.Len()
							return elem, consumed, nil
						}
						if isFlexible {
							lengthUint, err := protocol.ReadVaruint32(r)
							if err != nil {
								return err
							}
							if lengthUint < 1 {
								return errors.New("invalid compact array length")
							}
							length := int32(lengthUint - 1)
							// Collect all array elements into a buffer
							var arrayBuf bytes.Buffer
							for i := int32(0); i < length; i++ {
								// Read element into struct and encode to buffer
								var elemBuf bytes.Buffer
								elemW := &elemBuf
								var tempElem StreamsGroupHeartbeatRequestCopartitionGroup
								// SourceTopics
								if version >= 0 && version <= 999 {
									if isFlexible {
										val, err := protocol.ReadCompactInt16Array(r)
										if err != nil {
											return err
										}
										tempElem.SourceTopics = val
									} else {
										val, err := protocol.ReadInt16Array(r)
										if err != nil {
											return err
										}
										tempElem.SourceTopics = val
									}
								}
								// SourceTopicRegex
								if version >= 0 && version <= 999 {
									if isFlexible {
										val, err := protocol.ReadCompactInt16Array(r)
										if err != nil {
											return err
										}
										tempElem.SourceTopicRegex = val
									} else {
										val, err := protocol.ReadInt16Array(r)
										if err != nil {
											return err
										}
										tempElem.SourceTopicRegex = val
									}
								}
								// RepartitionSourceTopics
								if version >= 0 && version <= 999 {
									if isFlexible {
										val, err := protocol.ReadCompactInt16Array(r)
										if err != nil {
											return err
										}
										tempElem.RepartitionSourceTopics = val
									} else {
										val, err := protocol.ReadInt16Array(r)
										if err != nil {
											return err
										}
										tempElem.RepartitionSourceTopics = val
									}
								}
								// SourceTopics
								if version >= 0 && version <= 999 {
									if isFlexible {
										if err := protocol.WriteCompactInt16Array(elemW, tempElem.SourceTopics); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteInt16Array(elemW, tempElem.SourceTopics); err != nil {
											return err
										}
									}
								}
								// SourceTopicRegex
								if version >= 0 && version <= 999 {
									if isFlexible {
										if err := protocol.WriteCompactInt16Array(elemW, tempElem.SourceTopicRegex); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteInt16Array(elemW, tempElem.SourceTopicRegex); err != nil {
											return err
										}
									}
								}
								// RepartitionSourceTopics
								if version >= 0 && version <= 999 {
									if isFlexible {
										if err := protocol.WriteCompactInt16Array(elemW, tempElem.RepartitionSourceTopics); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteInt16Array(elemW, tempElem.RepartitionSourceTopics); err != nil {
											return err
										}
									}
								}
								// Append to array buffer
								arrayBuf.Write(elemBuf.Bytes())
							}
							// Prepend length and decode using DecodeCompactArray
							lengthBytes := protocol.EncodeVaruint32(lengthUint)
							fullData := append(lengthBytes, arrayBuf.Bytes()...)
							decoded, _, err := protocol.DecodeCompactArray(fullData, decoder)
							if err != nil {
								return err
							}
							// Convert []interface{} to typed slice
							tempElem.CopartitionGroups = make([]StreamsGroupHeartbeatRequestCopartitionGroup, len(decoded))
							for i, item := range decoded {
								tempElem.CopartitionGroups[i] = item.(StreamsGroupHeartbeatRequestCopartitionGroup)
							}
						} else {
							length, err := protocol.ReadInt32(r)
							if err != nil {
								return err
							}
							// Collect all array elements into a buffer
							var arrayBuf bytes.Buffer
							for i := int32(0); i < length; i++ {
								// Read element into struct and encode to buffer
								var elemBuf bytes.Buffer
								elemW := &elemBuf
								var tempElem StreamsGroupHeartbeatRequestCopartitionGroup
								// SourceTopics
								if version >= 0 && version <= 999 {
									if isFlexible {
										val, err := protocol.ReadCompactInt16Array(r)
										if err != nil {
											return err
										}
										tempElem.SourceTopics = val
									} else {
										val, err := protocol.ReadInt16Array(r)
										if err != nil {
											return err
										}
										tempElem.SourceTopics = val
									}
								}
								// SourceTopicRegex
								if version >= 0 && version <= 999 {
									if isFlexible {
										val, err := protocol.ReadCompactInt16Array(r)
										if err != nil {
											return err
										}
										tempElem.SourceTopicRegex = val
									} else {
										val, err := protocol.ReadInt16Array(r)
										if err != nil {
											return err
										}
										tempElem.SourceTopicRegex = val
									}
								}
								// RepartitionSourceTopics
								if version >= 0 && version <= 999 {
									if isFlexible {
										val, err := protocol.ReadCompactInt16Array(r)
										if err != nil {
											return err
										}
										tempElem.RepartitionSourceTopics = val
									} else {
										val, err := protocol.ReadInt16Array(r)
										if err != nil {
											return err
										}
										tempElem.RepartitionSourceTopics = val
									}
								}
								// SourceTopics
								if version >= 0 && version <= 999 {
									if isFlexible {
										if err := protocol.WriteCompactInt16Array(elemW, tempElem.SourceTopics); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteInt16Array(elemW, tempElem.SourceTopics); err != nil {
											return err
										}
									}
								}
								// SourceTopicRegex
								if version >= 0 && version <= 999 {
									if isFlexible {
										if err := protocol.WriteCompactInt16Array(elemW, tempElem.SourceTopicRegex); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteInt16Array(elemW, tempElem.SourceTopicRegex); err != nil {
											return err
										}
									}
								}
								// RepartitionSourceTopics
								if version >= 0 && version <= 999 {
									if isFlexible {
										if err := protocol.WriteCompactInt16Array(elemW, tempElem.RepartitionSourceTopics); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteInt16Array(elemW, tempElem.RepartitionSourceTopics); err != nil {
											return err
										}
									}
								}
								// Append to array buffer
								arrayBuf.Write(elemBuf.Bytes())
							}
							// Prepend length and decode using DecodeArray
							lengthBytes := protocol.EncodeInt32(length)
							fullData := append(lengthBytes, arrayBuf.Bytes()...)
							decoded, _, err := protocol.DecodeArray(fullData, decoder)
							if err != nil {
								return err
							}
							// Convert []interface{} to typed slice
							tempElem.CopartitionGroups = make([]StreamsGroupHeartbeatRequestCopartitionGroup, len(decoded))
							for i, item := range decoded {
								tempElem.CopartitionGroups[i] = item.(StreamsGroupHeartbeatRequestCopartitionGroup)
							}
						}
					}
					// SubtopologyId
					if version >= 0 && version <= 999 {
						if isFlexible {
							if err := protocol.WriteCompactString(elemW, tempElem.SubtopologyId); err != nil {
								return err
							}
						} else {
							if err := protocol.WriteString(elemW, tempElem.SubtopologyId); err != nil {
								return err
							}
						}
					}
					// SourceTopics
					if version >= 0 && version <= 999 {
						if isFlexible {
							if err := protocol.WriteCompactStringArray(elemW, tempElem.SourceTopics); err != nil {
								return err
							}
						} else {
							if err := protocol.WriteStringArray(elemW, tempElem.SourceTopics); err != nil {
								return err
							}
						}
					}
					// SourceTopicRegex
					if version >= 0 && version <= 999 {
						if isFlexible {
							if err := protocol.WriteCompactStringArray(elemW, tempElem.SourceTopicRegex); err != nil {
								return err
							}
						} else {
							if err := protocol.WriteStringArray(elemW, tempElem.SourceTopicRegex); err != nil {
								return err
							}
						}
					}
					// StateChangelogTopics
					if version >= 0 && version <= 999 {
						if isFlexible {
							length := uint32(len(tempElem.StateChangelogTopics) + 1)
							if err := protocol.WriteVaruint32(elemW, length); err != nil {
								return err
							}
						} else {
							if err := protocol.WriteInt32(elemW, int32(len(tempElem.StateChangelogTopics))); err != nil {
								return err
							}
						}
						for i := range tempElem.StateChangelogTopics {
							// Name
							if version >= 0 && version <= 999 {
								if isFlexible {
									if err := protocol.WriteCompactString(elemW, tempElem.StateChangelogTopics[i].Name); err != nil {
										return err
									}
								} else {
									if err := protocol.WriteString(elemW, tempElem.StateChangelogTopics[i].Name); err != nil {
										return err
									}
								}
							}
							// Partitions
							if version >= 0 && version <= 999 {
								if err := protocol.WriteInt32(elemW, tempElem.StateChangelogTopics[i].Partitions); err != nil {
									return err
								}
							}
							// ReplicationFactor
							if version >= 0 && version <= 999 {
								if err := protocol.WriteInt16(elemW, tempElem.StateChangelogTopics[i].ReplicationFactor); err != nil {
									return err
								}
							}
							// TopicConfigs
							if version >= 0 && version <= 999 {
								if isFlexible {
									length := uint32(len(tempElem.StateChangelogTopics[i].TopicConfigs) + 1)
									if err := protocol.WriteVaruint32(elemW, length); err != nil {
										return err
									}
								} else {
									if err := protocol.WriteInt32(elemW, int32(len(tempElem.StateChangelogTopics[i].TopicConfigs))); err != nil {
										return err
									}
								}
								for i := range tempElem.StateChangelogTopics[i].TopicConfigs {
									// Key
									if version >= 0 && version <= 999 {
										if isFlexible {
											if err := protocol.WriteCompactString(elemW, tempElem.StateChangelogTopics[i].TopicConfigs[i].Key); err != nil {
												return err
											}
										} else {
											if err := protocol.WriteString(elemW, tempElem.StateChangelogTopics[i].TopicConfigs[i].Key); err != nil {
												return err
											}
										}
									}
									// Value
									if version >= 0 && version <= 999 {
										if isFlexible {
											if err := protocol.WriteCompactString(elemW, tempElem.StateChangelogTopics[i].TopicConfigs[i].Value); err != nil {
												return err
											}
										} else {
											if err := protocol.WriteString(elemW, tempElem.StateChangelogTopics[i].TopicConfigs[i].Value); err != nil {
												return err
											}
										}
									}
								}
							}
						}
					}
					// RepartitionSinkTopics
					if version >= 0 && version <= 999 {
						if isFlexible {
							if err := protocol.WriteCompactStringArray(elemW, tempElem.RepartitionSinkTopics); err != nil {
								return err
							}
						} else {
							if err := protocol.WriteStringArray(elemW, tempElem.RepartitionSinkTopics); err != nil {
								return err
							}
						}
					}
					// RepartitionSourceTopics
					if version >= 0 && version <= 999 {
						if isFlexible {
							length := uint32(len(tempElem.RepartitionSourceTopics) + 1)
							if err := protocol.WriteVaruint32(elemW, length); err != nil {
								return err
							}
						} else {
							if err := protocol.WriteInt32(elemW, int32(len(tempElem.RepartitionSourceTopics))); err != nil {
								return err
							}
						}
						for i := range tempElem.RepartitionSourceTopics {
							// Name
							if version >= 0 && version <= 999 {
								if isFlexible {
									if err := protocol.WriteCompactString(elemW, tempElem.RepartitionSourceTopics[i].Name); err != nil {
										return err
									}
								} else {
									if err := protocol.WriteString(elemW, tempElem.RepartitionSourceTopics[i].Name); err != nil {
										return err
									}
								}
							}
							// Partitions
							if version >= 0 && version <= 999 {
								if err := protocol.WriteInt32(elemW, tempElem.RepartitionSourceTopics[i].Partitions); err != nil {
									return err
								}
							}
							// ReplicationFactor
							if version >= 0 && version <= 999 {
								if err := protocol.WriteInt16(elemW, tempElem.RepartitionSourceTopics[i].ReplicationFactor); err != nil {
									return err
								}
							}
							// TopicConfigs
							if version >= 0 && version <= 999 {
								if isFlexible {
									length := uint32(len(tempElem.RepartitionSourceTopics[i].TopicConfigs) + 1)
									if err := protocol.WriteVaruint32(elemW, length); err != nil {
										return err
									}
								} else {
									if err := protocol.WriteInt32(elemW, int32(len(tempElem.RepartitionSourceTopics[i].TopicConfigs))); err != nil {
										return err
									}
								}
								for i := range tempElem.RepartitionSourceTopics[i].TopicConfigs {
									// Key
									if version >= 0 && version <= 999 {
										if isFlexible {
											if err := protocol.WriteCompactString(elemW, tempElem.RepartitionSourceTopics[i].TopicConfigs[i].Key); err != nil {
												return err
											}
										} else {
											if err := protocol.WriteString(elemW, tempElem.RepartitionSourceTopics[i].TopicConfigs[i].Key); err != nil {
												return err
											}
										}
									}
									// Value
									if version >= 0 && version <= 999 {
										if isFlexible {
											if err := protocol.WriteCompactString(elemW, tempElem.RepartitionSourceTopics[i].TopicConfigs[i].Value); err != nil {
												return err
											}
										} else {
											if err := protocol.WriteString(elemW, tempElem.RepartitionSourceTopics[i].TopicConfigs[i].Value); err != nil {
												return err
											}
										}
									}
								}
							}
						}
					}
					// CopartitionGroups
					if version >= 0 && version <= 999 {
						if isFlexible {
							length := uint32(len(tempElem.CopartitionGroups) + 1)
							if err := protocol.WriteVaruint32(elemW, length); err != nil {
								return err
							}
						} else {
							if err := protocol.WriteInt32(elemW, int32(len(tempElem.CopartitionGroups))); err != nil {
								return err
							}
						}
						for i := range tempElem.CopartitionGroups {
							// SourceTopics
							if version >= 0 && version <= 999 {
								if isFlexible {
									if err := protocol.WriteCompactInt16Array(elemW, tempElem.CopartitionGroups[i].SourceTopics); err != nil {
										return err
									}
								} else {
									if err := protocol.WriteInt16Array(elemW, tempElem.CopartitionGroups[i].SourceTopics); err != nil {
										return err
									}
								}
							}
							// SourceTopicRegex
							if version >= 0 && version <= 999 {
								if isFlexible {
									if err := protocol.WriteCompactInt16Array(elemW, tempElem.CopartitionGroups[i].SourceTopicRegex); err != nil {
										return err
									}
								} else {
									if err := protocol.WriteInt16Array(elemW, tempElem.CopartitionGroups[i].SourceTopicRegex); err != nil {
										return err
									}
								}
							}
							// RepartitionSourceTopics
							if version >= 0 && version <= 999 {
								if isFlexible {
									if err := protocol.WriteCompactInt16Array(elemW, tempElem.CopartitionGroups[i].RepartitionSourceTopics); err != nil {
										return err
									}
								} else {
									if err := protocol.WriteInt16Array(elemW, tempElem.CopartitionGroups[i].RepartitionSourceTopics); err != nil {
										return err
									}
								}
							}
						}
					}
					// Append to array buffer
					arrayBuf.Write(elemBuf.Bytes())
				}
				// Prepend length and decode using DecodeCompactArray
				lengthBytes := protocol.EncodeVaruint32(lengthUint)
				fullData := append(lengthBytes, arrayBuf.Bytes()...)
				decoded, _, err := protocol.DecodeCompactArray(fullData, decoder)
				if err != nil {
					return err
				}
				// Convert []interface{} to typed slice
				m.Topology.Subtopologies = make([]StreamsGroupHeartbeatRequestSubtopology, len(decoded))
				for i, item := range decoded {
					m.Topology.Subtopologies[i] = item.(StreamsGroupHeartbeatRequestSubtopology)
				}
			} else {
				length, err := protocol.ReadInt32(r)
				if err != nil {
					return err
				}
				// Collect all array elements into a buffer
				var arrayBuf bytes.Buffer
				for i := int32(0); i < length; i++ {
					// Read element into struct and encode to buffer
					var elemBuf bytes.Buffer
					elemW := &elemBuf
					var tempElem StreamsGroupHeartbeatRequestSubtopology
					// SubtopologyId
					if version >= 0 && version <= 999 {
						if isFlexible {
							val, err := protocol.ReadCompactString(r)
							if err != nil {
								return err
							}
							tempElem.SubtopologyId = val
						} else {
							val, err := protocol.ReadString(r)
							if err != nil {
								return err
							}
							tempElem.SubtopologyId = val
						}
					}
					// SourceTopics
					if version >= 0 && version <= 999 {
						if isFlexible {
							val, err := protocol.ReadCompactStringArray(r)
							if err != nil {
								return err
							}
							tempElem.SourceTopics = val
						} else {
							val, err := protocol.ReadStringArray(r)
							if err != nil {
								return err
							}
							tempElem.SourceTopics = val
						}
					}
					// SourceTopicRegex
					if version >= 0 && version <= 999 {
						if isFlexible {
							val, err := protocol.ReadCompactStringArray(r)
							if err != nil {
								return err
							}
							tempElem.SourceTopicRegex = val
						} else {
							val, err := protocol.ReadStringArray(r)
							if err != nil {
								return err
							}
							tempElem.SourceTopicRegex = val
						}
					}
					// StateChangelogTopics
					if version >= 0 && version <= 999 {
						// Decode array using ArrayDecoder
						decoder := func(data []byte) (interface{}, int, error) {
							var elem TopicInfo
							elemR := bytes.NewReader(data)
							// Name
							if version >= 0 && version <= 999 {
								if isFlexible {
									val, err := protocol.ReadCompactString(elemR)
									if err != nil {
										return nil, 0, err
									}
									elem.Name = val
								} else {
									val, err := protocol.ReadString(elemR)
									if err != nil {
										return nil, 0, err
									}
									elem.Name = val
								}
							}
							// Partitions
							if version >= 0 && version <= 999 {
								val, err := protocol.ReadInt32(elemR)
								if err != nil {
									return nil, 0, err
								}
								elem.Partitions = val
							}
							// ReplicationFactor
							if version >= 0 && version <= 999 {
								val, err := protocol.ReadInt16(elemR)
								if err != nil {
									return nil, 0, err
								}
								elem.ReplicationFactor = val
							}
							// TopicConfigs
							if version >= 0 && version <= 999 {
								// Nested array in decoder - manual handling needed
								return nil, 0, errors.New("nested arrays in decoder not fully supported")
							}
							consumed := len(data) - elemR.Len()
							return elem, consumed, nil
						}
						if isFlexible {
							lengthUint, err := protocol.ReadVaruint32(r)
							if err != nil {
								return err
							}
							if lengthUint < 1 {
								return errors.New("invalid compact array length")
							}
							length := int32(lengthUint - 1)
							// Collect all array elements into a buffer
							var arrayBuf bytes.Buffer
							for i := int32(0); i < length; i++ {
								// Read element into struct and encode to buffer
								var elemBuf bytes.Buffer
								elemW := &elemBuf
								var tempElem TopicInfo
								// Name
								if version >= 0 && version <= 999 {
									if isFlexible {
										val, err := protocol.ReadCompactString(r)
										if err != nil {
											return err
										}
										tempElem.Name = val
									} else {
										val, err := protocol.ReadString(r)
										if err != nil {
											return err
										}
										tempElem.Name = val
									}
								}
								// Partitions
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt32(r)
									if err != nil {
										return err
									}
									tempElem.Partitions = val
								}
								// ReplicationFactor
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt16(r)
									if err != nil {
										return err
									}
									tempElem.ReplicationFactor = val
								}
								// TopicConfigs
								if version >= 0 && version <= 999 {
									// Decode array using ArrayDecoder
									decoder := func(data []byte) (interface{}, int, error) {
										var elem KeyValue
										elemR := bytes.NewReader(data)
										// Key
										if version >= 0 && version <= 999 {
											if isFlexible {
												val, err := protocol.ReadCompactString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Key = val
											} else {
												val, err := protocol.ReadString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Key = val
											}
										}
										// Value
										if version >= 0 && version <= 999 {
											if isFlexible {
												val, err := protocol.ReadCompactString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Value = val
											} else {
												val, err := protocol.ReadString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Value = val
											}
										}
										consumed := len(data) - elemR.Len()
										return elem, consumed, nil
									}
									if isFlexible {
										lengthUint, err := protocol.ReadVaruint32(r)
										if err != nil {
											return err
										}
										if lengthUint < 1 {
											return errors.New("invalid compact array length")
										}
										length := int32(lengthUint - 1)
										// Collect all array elements into a buffer
										var arrayBuf bytes.Buffer
										for i := int32(0); i < length; i++ {
											// Read element into struct and encode to buffer
											var elemBuf bytes.Buffer
											elemW := &elemBuf
											var tempElem KeyValue
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												}
											}
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Key); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Key); err != nil {
														return err
													}
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Value); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Value); err != nil {
														return err
													}
												}
											}
											// Append to array buffer
											arrayBuf.Write(elemBuf.Bytes())
										}
										// Prepend length and decode using DecodeCompactArray
										lengthBytes := protocol.EncodeVaruint32(lengthUint)
										fullData := append(lengthBytes, arrayBuf.Bytes()...)
										decoded, _, err := protocol.DecodeCompactArray(fullData, decoder)
										if err != nil {
											return err
										}
										// Convert []interface{} to typed slice
										tempElem.TopicConfigs = make([]KeyValue, len(decoded))
										for i, item := range decoded {
											tempElem.TopicConfigs[i] = item.(KeyValue)
										}
									} else {
										length, err := protocol.ReadInt32(r)
										if err != nil {
											return err
										}
										// Collect all array elements into a buffer
										var arrayBuf bytes.Buffer
										for i := int32(0); i < length; i++ {
											// Read element into struct and encode to buffer
											var elemBuf bytes.Buffer
											elemW := &elemBuf
											var tempElem KeyValue
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												}
											}
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Key); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Key); err != nil {
														return err
													}
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Value); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Value); err != nil {
														return err
													}
												}
											}
											// Append to array buffer
											arrayBuf.Write(elemBuf.Bytes())
										}
										// Prepend length and decode using DecodeArray
										lengthBytes := protocol.EncodeInt32(length)
										fullData := append(lengthBytes, arrayBuf.Bytes()...)
										decoded, _, err := protocol.DecodeArray(fullData, decoder)
										if err != nil {
											return err
										}
										// Convert []interface{} to typed slice
										tempElem.TopicConfigs = make([]KeyValue, len(decoded))
										for i, item := range decoded {
											tempElem.TopicConfigs[i] = item.(KeyValue)
										}
									}
								}
								// Name
								if version >= 0 && version <= 999 {
									if isFlexible {
										if err := protocol.WriteCompactString(elemW, tempElem.Name); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteString(elemW, tempElem.Name); err != nil {
											return err
										}
									}
								}
								// Partitions
								if version >= 0 && version <= 999 {
									if err := protocol.WriteInt32(elemW, tempElem.Partitions); err != nil {
										return err
									}
								}
								// ReplicationFactor
								if version >= 0 && version <= 999 {
									if err := protocol.WriteInt16(elemW, tempElem.ReplicationFactor); err != nil {
										return err
									}
								}
								// TopicConfigs
								if version >= 0 && version <= 999 {
									if isFlexible {
										length := uint32(len(tempElem.TopicConfigs) + 1)
										if err := protocol.WriteVaruint32(elemW, length); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteInt32(elemW, int32(len(tempElem.TopicConfigs))); err != nil {
											return err
										}
									}
									for i := range tempElem.TopicConfigs {
										// Key
										if version >= 0 && version <= 999 {
											if isFlexible {
												if err := protocol.WriteCompactString(elemW, tempElem.TopicConfigs[i].Key); err != nil {
													return err
												}
											} else {
												if err := protocol.WriteString(elemW, tempElem.TopicConfigs[i].Key); err != nil {
													return err
												}
											}
										}
										// Value
										if version >= 0 && version <= 999 {
											if isFlexible {
												if err := protocol.WriteCompactString(elemW, tempElem.TopicConfigs[i].Value); err != nil {
													return err
												}
											} else {
												if err := protocol.WriteString(elemW, tempElem.TopicConfigs[i].Value); err != nil {
													return err
												}
											}
										}
									}
								}
								// Append to array buffer
								arrayBuf.Write(elemBuf.Bytes())
							}
							// Prepend length and decode using DecodeCompactArray
							lengthBytes := protocol.EncodeVaruint32(lengthUint)
							fullData := append(lengthBytes, arrayBuf.Bytes()...)
							decoded, _, err := protocol.DecodeCompactArray(fullData, decoder)
							if err != nil {
								return err
							}
							// Convert []interface{} to typed slice
							tempElem.StateChangelogTopics = make([]TopicInfo, len(decoded))
							for i, item := range decoded {
								tempElem.StateChangelogTopics[i] = item.(TopicInfo)
							}
						} else {
							length, err := protocol.ReadInt32(r)
							if err != nil {
								return err
							}
							// Collect all array elements into a buffer
							var arrayBuf bytes.Buffer
							for i := int32(0); i < length; i++ {
								// Read element into struct and encode to buffer
								var elemBuf bytes.Buffer
								elemW := &elemBuf
								var tempElem TopicInfo
								// Name
								if version >= 0 && version <= 999 {
									if isFlexible {
										val, err := protocol.ReadCompactString(r)
										if err != nil {
											return err
										}
										tempElem.Name = val
									} else {
										val, err := protocol.ReadString(r)
										if err != nil {
											return err
										}
										tempElem.Name = val
									}
								}
								// Partitions
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt32(r)
									if err != nil {
										return err
									}
									tempElem.Partitions = val
								}
								// ReplicationFactor
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt16(r)
									if err != nil {
										return err
									}
									tempElem.ReplicationFactor = val
								}
								// TopicConfigs
								if version >= 0 && version <= 999 {
									// Decode array using ArrayDecoder
									decoder := func(data []byte) (interface{}, int, error) {
										var elem KeyValue
										elemR := bytes.NewReader(data)
										// Key
										if version >= 0 && version <= 999 {
											if isFlexible {
												val, err := protocol.ReadCompactString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Key = val
											} else {
												val, err := protocol.ReadString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Key = val
											}
										}
										// Value
										if version >= 0 && version <= 999 {
											if isFlexible {
												val, err := protocol.ReadCompactString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Value = val
											} else {
												val, err := protocol.ReadString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Value = val
											}
										}
										consumed := len(data) - elemR.Len()
										return elem, consumed, nil
									}
									if isFlexible {
										lengthUint, err := protocol.ReadVaruint32(r)
										if err != nil {
											return err
										}
										if lengthUint < 1 {
											return errors.New("invalid compact array length")
										}
										length := int32(lengthUint - 1)
										// Collect all array elements into a buffer
										var arrayBuf bytes.Buffer
										for i := int32(0); i < length; i++ {
											// Read element into struct and encode to buffer
											var elemBuf bytes.Buffer
											elemW := &elemBuf
											var tempElem KeyValue
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												}
											}
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Key); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Key); err != nil {
														return err
													}
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Value); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Value); err != nil {
														return err
													}
												}
											}
											// Append to array buffer
											arrayBuf.Write(elemBuf.Bytes())
										}
										// Prepend length and decode using DecodeCompactArray
										lengthBytes := protocol.EncodeVaruint32(lengthUint)
										fullData := append(lengthBytes, arrayBuf.Bytes()...)
										decoded, _, err := protocol.DecodeCompactArray(fullData, decoder)
										if err != nil {
											return err
										}
										// Convert []interface{} to typed slice
										tempElem.TopicConfigs = make([]KeyValue, len(decoded))
										for i, item := range decoded {
											tempElem.TopicConfigs[i] = item.(KeyValue)
										}
									} else {
										length, err := protocol.ReadInt32(r)
										if err != nil {
											return err
										}
										// Collect all array elements into a buffer
										var arrayBuf bytes.Buffer
										for i := int32(0); i < length; i++ {
											// Read element into struct and encode to buffer
											var elemBuf bytes.Buffer
											elemW := &elemBuf
											var tempElem KeyValue
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												}
											}
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Key); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Key); err != nil {
														return err
													}
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Value); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Value); err != nil {
														return err
													}
												}
											}
											// Append to array buffer
											arrayBuf.Write(elemBuf.Bytes())
										}
										// Prepend length and decode using DecodeArray
										lengthBytes := protocol.EncodeInt32(length)
										fullData := append(lengthBytes, arrayBuf.Bytes()...)
										decoded, _, err := protocol.DecodeArray(fullData, decoder)
										if err != nil {
											return err
										}
										// Convert []interface{} to typed slice
										tempElem.TopicConfigs = make([]KeyValue, len(decoded))
										for i, item := range decoded {
											tempElem.TopicConfigs[i] = item.(KeyValue)
										}
									}
								}
								// Name
								if version >= 0 && version <= 999 {
									if isFlexible {
										if err := protocol.WriteCompactString(elemW, tempElem.Name); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteString(elemW, tempElem.Name); err != nil {
											return err
										}
									}
								}
								// Partitions
								if version >= 0 && version <= 999 {
									if err := protocol.WriteInt32(elemW, tempElem.Partitions); err != nil {
										return err
									}
								}
								// ReplicationFactor
								if version >= 0 && version <= 999 {
									if err := protocol.WriteInt16(elemW, tempElem.ReplicationFactor); err != nil {
										return err
									}
								}
								// TopicConfigs
								if version >= 0 && version <= 999 {
									if isFlexible {
										length := uint32(len(tempElem.TopicConfigs) + 1)
										if err := protocol.WriteVaruint32(elemW, length); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteInt32(elemW, int32(len(tempElem.TopicConfigs))); err != nil {
											return err
										}
									}
									for i := range tempElem.TopicConfigs {
										// Key
										if version >= 0 && version <= 999 {
											if isFlexible {
												if err := protocol.WriteCompactString(elemW, tempElem.TopicConfigs[i].Key); err != nil {
													return err
												}
											} else {
												if err := protocol.WriteString(elemW, tempElem.TopicConfigs[i].Key); err != nil {
													return err
												}
											}
										}
										// Value
										if version >= 0 && version <= 999 {
											if isFlexible {
												if err := protocol.WriteCompactString(elemW, tempElem.TopicConfigs[i].Value); err != nil {
													return err
												}
											} else {
												if err := protocol.WriteString(elemW, tempElem.TopicConfigs[i].Value); err != nil {
													return err
												}
											}
										}
									}
								}
								// Append to array buffer
								arrayBuf.Write(elemBuf.Bytes())
							}
							// Prepend length and decode using DecodeArray
							lengthBytes := protocol.EncodeInt32(length)
							fullData := append(lengthBytes, arrayBuf.Bytes()...)
							decoded, _, err := protocol.DecodeArray(fullData, decoder)
							if err != nil {
								return err
							}
							// Convert []interface{} to typed slice
							tempElem.StateChangelogTopics = make([]TopicInfo, len(decoded))
							for i, item := range decoded {
								tempElem.StateChangelogTopics[i] = item.(TopicInfo)
							}
						}
					}
					// RepartitionSinkTopics
					if version >= 0 && version <= 999 {
						if isFlexible {
							val, err := protocol.ReadCompactStringArray(r)
							if err != nil {
								return err
							}
							tempElem.RepartitionSinkTopics = val
						} else {
							val, err := protocol.ReadStringArray(r)
							if err != nil {
								return err
							}
							tempElem.RepartitionSinkTopics = val
						}
					}
					// RepartitionSourceTopics
					if version >= 0 && version <= 999 {
						// Decode array using ArrayDecoder
						decoder := func(data []byte) (interface{}, int, error) {
							var elem TopicInfo
							elemR := bytes.NewReader(data)
							// Name
							if version >= 0 && version <= 999 {
								if isFlexible {
									val, err := protocol.ReadCompactString(elemR)
									if err != nil {
										return nil, 0, err
									}
									elem.Name = val
								} else {
									val, err := protocol.ReadString(elemR)
									if err != nil {
										return nil, 0, err
									}
									elem.Name = val
								}
							}
							// Partitions
							if version >= 0 && version <= 999 {
								val, err := protocol.ReadInt32(elemR)
								if err != nil {
									return nil, 0, err
								}
								elem.Partitions = val
							}
							// ReplicationFactor
							if version >= 0 && version <= 999 {
								val, err := protocol.ReadInt16(elemR)
								if err != nil {
									return nil, 0, err
								}
								elem.ReplicationFactor = val
							}
							// TopicConfigs
							if version >= 0 && version <= 999 {
								// Nested array in decoder - manual handling needed
								return nil, 0, errors.New("nested arrays in decoder not fully supported")
							}
							consumed := len(data) - elemR.Len()
							return elem, consumed, nil
						}
						if isFlexible {
							lengthUint, err := protocol.ReadVaruint32(r)
							if err != nil {
								return err
							}
							if lengthUint < 1 {
								return errors.New("invalid compact array length")
							}
							length := int32(lengthUint - 1)
							// Collect all array elements into a buffer
							var arrayBuf bytes.Buffer
							for i := int32(0); i < length; i++ {
								// Read element into struct and encode to buffer
								var elemBuf bytes.Buffer
								elemW := &elemBuf
								var tempElem TopicInfo
								// Name
								if version >= 0 && version <= 999 {
									if isFlexible {
										val, err := protocol.ReadCompactString(r)
										if err != nil {
											return err
										}
										tempElem.Name = val
									} else {
										val, err := protocol.ReadString(r)
										if err != nil {
											return err
										}
										tempElem.Name = val
									}
								}
								// Partitions
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt32(r)
									if err != nil {
										return err
									}
									tempElem.Partitions = val
								}
								// ReplicationFactor
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt16(r)
									if err != nil {
										return err
									}
									tempElem.ReplicationFactor = val
								}
								// TopicConfigs
								if version >= 0 && version <= 999 {
									// Decode array using ArrayDecoder
									decoder := func(data []byte) (interface{}, int, error) {
										var elem KeyValue
										elemR := bytes.NewReader(data)
										// Key
										if version >= 0 && version <= 999 {
											if isFlexible {
												val, err := protocol.ReadCompactString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Key = val
											} else {
												val, err := protocol.ReadString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Key = val
											}
										}
										// Value
										if version >= 0 && version <= 999 {
											if isFlexible {
												val, err := protocol.ReadCompactString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Value = val
											} else {
												val, err := protocol.ReadString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Value = val
											}
										}
										consumed := len(data) - elemR.Len()
										return elem, consumed, nil
									}
									if isFlexible {
										lengthUint, err := protocol.ReadVaruint32(r)
										if err != nil {
											return err
										}
										if lengthUint < 1 {
											return errors.New("invalid compact array length")
										}
										length := int32(lengthUint - 1)
										// Collect all array elements into a buffer
										var arrayBuf bytes.Buffer
										for i := int32(0); i < length; i++ {
											// Read element into struct and encode to buffer
											var elemBuf bytes.Buffer
											elemW := &elemBuf
											var tempElem KeyValue
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												}
											}
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Key); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Key); err != nil {
														return err
													}
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Value); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Value); err != nil {
														return err
													}
												}
											}
											// Append to array buffer
											arrayBuf.Write(elemBuf.Bytes())
										}
										// Prepend length and decode using DecodeCompactArray
										lengthBytes := protocol.EncodeVaruint32(lengthUint)
										fullData := append(lengthBytes, arrayBuf.Bytes()...)
										decoded, _, err := protocol.DecodeCompactArray(fullData, decoder)
										if err != nil {
											return err
										}
										// Convert []interface{} to typed slice
										tempElem.TopicConfigs = make([]KeyValue, len(decoded))
										for i, item := range decoded {
											tempElem.TopicConfigs[i] = item.(KeyValue)
										}
									} else {
										length, err := protocol.ReadInt32(r)
										if err != nil {
											return err
										}
										// Collect all array elements into a buffer
										var arrayBuf bytes.Buffer
										for i := int32(0); i < length; i++ {
											// Read element into struct and encode to buffer
											var elemBuf bytes.Buffer
											elemW := &elemBuf
											var tempElem KeyValue
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												}
											}
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Key); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Key); err != nil {
														return err
													}
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Value); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Value); err != nil {
														return err
													}
												}
											}
											// Append to array buffer
											arrayBuf.Write(elemBuf.Bytes())
										}
										// Prepend length and decode using DecodeArray
										lengthBytes := protocol.EncodeInt32(length)
										fullData := append(lengthBytes, arrayBuf.Bytes()...)
										decoded, _, err := protocol.DecodeArray(fullData, decoder)
										if err != nil {
											return err
										}
										// Convert []interface{} to typed slice
										tempElem.TopicConfigs = make([]KeyValue, len(decoded))
										for i, item := range decoded {
											tempElem.TopicConfigs[i] = item.(KeyValue)
										}
									}
								}
								// Name
								if version >= 0 && version <= 999 {
									if isFlexible {
										if err := protocol.WriteCompactString(elemW, tempElem.Name); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteString(elemW, tempElem.Name); err != nil {
											return err
										}
									}
								}
								// Partitions
								if version >= 0 && version <= 999 {
									if err := protocol.WriteInt32(elemW, tempElem.Partitions); err != nil {
										return err
									}
								}
								// ReplicationFactor
								if version >= 0 && version <= 999 {
									if err := protocol.WriteInt16(elemW, tempElem.ReplicationFactor); err != nil {
										return err
									}
								}
								// TopicConfigs
								if version >= 0 && version <= 999 {
									if isFlexible {
										length := uint32(len(tempElem.TopicConfigs) + 1)
										if err := protocol.WriteVaruint32(elemW, length); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteInt32(elemW, int32(len(tempElem.TopicConfigs))); err != nil {
											return err
										}
									}
									for i := range tempElem.TopicConfigs {
										// Key
										if version >= 0 && version <= 999 {
											if isFlexible {
												if err := protocol.WriteCompactString(elemW, tempElem.TopicConfigs[i].Key); err != nil {
													return err
												}
											} else {
												if err := protocol.WriteString(elemW, tempElem.TopicConfigs[i].Key); err != nil {
													return err
												}
											}
										}
										// Value
										if version >= 0 && version <= 999 {
											if isFlexible {
												if err := protocol.WriteCompactString(elemW, tempElem.TopicConfigs[i].Value); err != nil {
													return err
												}
											} else {
												if err := protocol.WriteString(elemW, tempElem.TopicConfigs[i].Value); err != nil {
													return err
												}
											}
										}
									}
								}
								// Append to array buffer
								arrayBuf.Write(elemBuf.Bytes())
							}
							// Prepend length and decode using DecodeCompactArray
							lengthBytes := protocol.EncodeVaruint32(lengthUint)
							fullData := append(lengthBytes, arrayBuf.Bytes()...)
							decoded, _, err := protocol.DecodeCompactArray(fullData, decoder)
							if err != nil {
								return err
							}
							// Convert []interface{} to typed slice
							tempElem.RepartitionSourceTopics = make([]TopicInfo, len(decoded))
							for i, item := range decoded {
								tempElem.RepartitionSourceTopics[i] = item.(TopicInfo)
							}
						} else {
							length, err := protocol.ReadInt32(r)
							if err != nil {
								return err
							}
							// Collect all array elements into a buffer
							var arrayBuf bytes.Buffer
							for i := int32(0); i < length; i++ {
								// Read element into struct and encode to buffer
								var elemBuf bytes.Buffer
								elemW := &elemBuf
								var tempElem TopicInfo
								// Name
								if version >= 0 && version <= 999 {
									if isFlexible {
										val, err := protocol.ReadCompactString(r)
										if err != nil {
											return err
										}
										tempElem.Name = val
									} else {
										val, err := protocol.ReadString(r)
										if err != nil {
											return err
										}
										tempElem.Name = val
									}
								}
								// Partitions
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt32(r)
									if err != nil {
										return err
									}
									tempElem.Partitions = val
								}
								// ReplicationFactor
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt16(r)
									if err != nil {
										return err
									}
									tempElem.ReplicationFactor = val
								}
								// TopicConfigs
								if version >= 0 && version <= 999 {
									// Decode array using ArrayDecoder
									decoder := func(data []byte) (interface{}, int, error) {
										var elem KeyValue
										elemR := bytes.NewReader(data)
										// Key
										if version >= 0 && version <= 999 {
											if isFlexible {
												val, err := protocol.ReadCompactString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Key = val
											} else {
												val, err := protocol.ReadString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Key = val
											}
										}
										// Value
										if version >= 0 && version <= 999 {
											if isFlexible {
												val, err := protocol.ReadCompactString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Value = val
											} else {
												val, err := protocol.ReadString(elemR)
												if err != nil {
													return nil, 0, err
												}
												elem.Value = val
											}
										}
										consumed := len(data) - elemR.Len()
										return elem, consumed, nil
									}
									if isFlexible {
										lengthUint, err := protocol.ReadVaruint32(r)
										if err != nil {
											return err
										}
										if lengthUint < 1 {
											return errors.New("invalid compact array length")
										}
										length := int32(lengthUint - 1)
										// Collect all array elements into a buffer
										var arrayBuf bytes.Buffer
										for i := int32(0); i < length; i++ {
											// Read element into struct and encode to buffer
											var elemBuf bytes.Buffer
											elemW := &elemBuf
											var tempElem KeyValue
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												}
											}
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Key); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Key); err != nil {
														return err
													}
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Value); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Value); err != nil {
														return err
													}
												}
											}
											// Append to array buffer
											arrayBuf.Write(elemBuf.Bytes())
										}
										// Prepend length and decode using DecodeCompactArray
										lengthBytes := protocol.EncodeVaruint32(lengthUint)
										fullData := append(lengthBytes, arrayBuf.Bytes()...)
										decoded, _, err := protocol.DecodeCompactArray(fullData, decoder)
										if err != nil {
											return err
										}
										// Convert []interface{} to typed slice
										tempElem.TopicConfigs = make([]KeyValue, len(decoded))
										for i, item := range decoded {
											tempElem.TopicConfigs[i] = item.(KeyValue)
										}
									} else {
										length, err := protocol.ReadInt32(r)
										if err != nil {
											return err
										}
										// Collect all array elements into a buffer
										var arrayBuf bytes.Buffer
										for i := int32(0); i < length; i++ {
											// Read element into struct and encode to buffer
											var elemBuf bytes.Buffer
											elemW := &elemBuf
											var tempElem KeyValue
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													tempElem.Value = val
												}
											}
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Key); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Key); err != nil {
														return err
													}
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													if err := protocol.WriteCompactString(elemW, tempElem.Value); err != nil {
														return err
													}
												} else {
													if err := protocol.WriteString(elemW, tempElem.Value); err != nil {
														return err
													}
												}
											}
											// Append to array buffer
											arrayBuf.Write(elemBuf.Bytes())
										}
										// Prepend length and decode using DecodeArray
										lengthBytes := protocol.EncodeInt32(length)
										fullData := append(lengthBytes, arrayBuf.Bytes()...)
										decoded, _, err := protocol.DecodeArray(fullData, decoder)
										if err != nil {
											return err
										}
										// Convert []interface{} to typed slice
										tempElem.TopicConfigs = make([]KeyValue, len(decoded))
										for i, item := range decoded {
											tempElem.TopicConfigs[i] = item.(KeyValue)
										}
									}
								}
								// Name
								if version >= 0 && version <= 999 {
									if isFlexible {
										if err := protocol.WriteCompactString(elemW, tempElem.Name); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteString(elemW, tempElem.Name); err != nil {
											return err
										}
									}
								}
								// Partitions
								if version >= 0 && version <= 999 {
									if err := protocol.WriteInt32(elemW, tempElem.Partitions); err != nil {
										return err
									}
								}
								// ReplicationFactor
								if version >= 0 && version <= 999 {
									if err := protocol.WriteInt16(elemW, tempElem.ReplicationFactor); err != nil {
										return err
									}
								}
								// TopicConfigs
								if version >= 0 && version <= 999 {
									if isFlexible {
										length := uint32(len(tempElem.TopicConfigs) + 1)
										if err := protocol.WriteVaruint32(elemW, length); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteInt32(elemW, int32(len(tempElem.TopicConfigs))); err != nil {
											return err
										}
									}
									for i := range tempElem.TopicConfigs {
										// Key
										if version >= 0 && version <= 999 {
											if isFlexible {
												if err := protocol.WriteCompactString(elemW, tempElem.TopicConfigs[i].Key); err != nil {
													return err
												}
											} else {
												if err := protocol.WriteString(elemW, tempElem.TopicConfigs[i].Key); err != nil {
													return err
												}
											}
										}
										// Value
										if version >= 0 && version <= 999 {
											if isFlexible {
												if err := protocol.WriteCompactString(elemW, tempElem.TopicConfigs[i].Value); err != nil {
													return err
												}
											} else {
												if err := protocol.WriteString(elemW, tempElem.TopicConfigs[i].Value); err != nil {
													return err
												}
											}
										}
									}
								}
								// Append to array buffer
								arrayBuf.Write(elemBuf.Bytes())
							}
							// Prepend length and decode using DecodeArray
							lengthBytes := protocol.EncodeInt32(length)
							fullData := append(lengthBytes, arrayBuf.Bytes()...)
							decoded, _, err := protocol.DecodeArray(fullData, decoder)
							if err != nil {
								return err
							}
							// Convert []interface{} to typed slice
							tempElem.RepartitionSourceTopics = make([]TopicInfo, len(decoded))
							for i, item := range decoded {
								tempElem.RepartitionSourceTopics[i] = item.(TopicInfo)
							}
						}
					}
					// CopartitionGroups
					if version >= 0 && version <= 999 {
						// Decode array using ArrayDecoder
						decoder := func(data []byte) (interface{}, int, error) {
							var elem StreamsGroupHeartbeatRequestCopartitionGroup
							elemR := bytes.NewReader(data)
							// SourceTopics
							if version >= 0 && version <= 999 {
								if isFlexible {
									val, err := protocol.ReadCompactInt16Array(elemR)
									if err != nil {
										return nil, 0, err
									}
									elem.SourceTopics = val
								} else {
									val, err := protocol.ReadInt16Array(elemR)
									if err != nil {
										return nil, 0, err
									}
									elem.SourceTopics = val
								}
							}
							// SourceTopicRegex
							if version >= 0 && version <= 999 {
								if isFlexible {
									val, err := protocol.ReadCompactInt16Array(elemR)
									if err != nil {
										return nil, 0, err
									}
									elem.SourceTopicRegex = val
								} else {
									val, err := protocol.ReadInt16Array(elemR)
									if err != nil {
										return nil, 0, err
									}
									elem.SourceTopicRegex = val
								}
							}
							// RepartitionSourceTopics
							if version >= 0 && version <= 999 {
								if isFlexible {
									val, err := protocol.ReadCompactInt16Array(elemR)
									if err != nil {
										return nil, 0, err
									}
									elem.RepartitionSourceTopics = val
								} else {
									val, err := protocol.ReadInt16Array(elemR)
									if err != nil {
										return nil, 0, err
									}
									elem.RepartitionSourceTopics = val
								}
							}
							consumed := len(data) - elemR.Len()
							return elem, consumed, nil
						}
						if isFlexible {
							lengthUint, err := protocol.ReadVaruint32(r)
							if err != nil {
								return err
							}
							if lengthUint < 1 {
								return errors.New("invalid compact array length")
							}
							length := int32(lengthUint - 1)
							// Collect all array elements into a buffer
							var arrayBuf bytes.Buffer
							for i := int32(0); i < length; i++ {
								// Read element into struct and encode to buffer
								var elemBuf bytes.Buffer
								elemW := &elemBuf
								var tempElem StreamsGroupHeartbeatRequestCopartitionGroup
								// SourceTopics
								if version >= 0 && version <= 999 {
									if isFlexible {
										val, err := protocol.ReadCompactInt16Array(r)
										if err != nil {
											return err
										}
										tempElem.SourceTopics = val
									} else {
										val, err := protocol.ReadInt16Array(r)
										if err != nil {
											return err
										}
										tempElem.SourceTopics = val
									}
								}
								// SourceTopicRegex
								if version >= 0 && version <= 999 {
									if isFlexible {
										val, err := protocol.ReadCompactInt16Array(r)
										if err != nil {
											return err
										}
										tempElem.SourceTopicRegex = val
									} else {
										val, err := protocol.ReadInt16Array(r)
										if err != nil {
											return err
										}
										tempElem.SourceTopicRegex = val
									}
								}
								// RepartitionSourceTopics
								if version >= 0 && version <= 999 {
									if isFlexible {
										val, err := protocol.ReadCompactInt16Array(r)
										if err != nil {
											return err
										}
										tempElem.RepartitionSourceTopics = val
									} else {
										val, err := protocol.ReadInt16Array(r)
										if err != nil {
											return err
										}
										tempElem.RepartitionSourceTopics = val
									}
								}
								// SourceTopics
								if version >= 0 && version <= 999 {
									if isFlexible {
										if err := protocol.WriteCompactInt16Array(elemW, tempElem.SourceTopics); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteInt16Array(elemW, tempElem.SourceTopics); err != nil {
											return err
										}
									}
								}
								// SourceTopicRegex
								if version >= 0 && version <= 999 {
									if isFlexible {
										if err := protocol.WriteCompactInt16Array(elemW, tempElem.SourceTopicRegex); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteInt16Array(elemW, tempElem.SourceTopicRegex); err != nil {
											return err
										}
									}
								}
								// RepartitionSourceTopics
								if version >= 0 && version <= 999 {
									if isFlexible {
										if err := protocol.WriteCompactInt16Array(elemW, tempElem.RepartitionSourceTopics); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteInt16Array(elemW, tempElem.RepartitionSourceTopics); err != nil {
											return err
										}
									}
								}
								// Append to array buffer
								arrayBuf.Write(elemBuf.Bytes())
							}
							// Prepend length and decode using DecodeCompactArray
							lengthBytes := protocol.EncodeVaruint32(lengthUint)
							fullData := append(lengthBytes, arrayBuf.Bytes()...)
							decoded, _, err := protocol.DecodeCompactArray(fullData, decoder)
							if err != nil {
								return err
							}
							// Convert []interface{} to typed slice
							tempElem.CopartitionGroups = make([]StreamsGroupHeartbeatRequestCopartitionGroup, len(decoded))
							for i, item := range decoded {
								tempElem.CopartitionGroups[i] = item.(StreamsGroupHeartbeatRequestCopartitionGroup)
							}
						} else {
							length, err := protocol.ReadInt32(r)
							if err != nil {
								return err
							}
							// Collect all array elements into a buffer
							var arrayBuf bytes.Buffer
							for i := int32(0); i < length; i++ {
								// Read element into struct and encode to buffer
								var elemBuf bytes.Buffer
								elemW := &elemBuf
								var tempElem StreamsGroupHeartbeatRequestCopartitionGroup
								// SourceTopics
								if version >= 0 && version <= 999 {
									if isFlexible {
										val, err := protocol.ReadCompactInt16Array(r)
										if err != nil {
											return err
										}
										tempElem.SourceTopics = val
									} else {
										val, err := protocol.ReadInt16Array(r)
										if err != nil {
											return err
										}
										tempElem.SourceTopics = val
									}
								}
								// SourceTopicRegex
								if version >= 0 && version <= 999 {
									if isFlexible {
										val, err := protocol.ReadCompactInt16Array(r)
										if err != nil {
											return err
										}
										tempElem.SourceTopicRegex = val
									} else {
										val, err := protocol.ReadInt16Array(r)
										if err != nil {
											return err
										}
										tempElem.SourceTopicRegex = val
									}
								}
								// RepartitionSourceTopics
								if version >= 0 && version <= 999 {
									if isFlexible {
										val, err := protocol.ReadCompactInt16Array(r)
										if err != nil {
											return err
										}
										tempElem.RepartitionSourceTopics = val
									} else {
										val, err := protocol.ReadInt16Array(r)
										if err != nil {
											return err
										}
										tempElem.RepartitionSourceTopics = val
									}
								}
								// SourceTopics
								if version >= 0 && version <= 999 {
									if isFlexible {
										if err := protocol.WriteCompactInt16Array(elemW, tempElem.SourceTopics); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteInt16Array(elemW, tempElem.SourceTopics); err != nil {
											return err
										}
									}
								}
								// SourceTopicRegex
								if version >= 0 && version <= 999 {
									if isFlexible {
										if err := protocol.WriteCompactInt16Array(elemW, tempElem.SourceTopicRegex); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteInt16Array(elemW, tempElem.SourceTopicRegex); err != nil {
											return err
										}
									}
								}
								// RepartitionSourceTopics
								if version >= 0 && version <= 999 {
									if isFlexible {
										if err := protocol.WriteCompactInt16Array(elemW, tempElem.RepartitionSourceTopics); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteInt16Array(elemW, tempElem.RepartitionSourceTopics); err != nil {
											return err
										}
									}
								}
								// Append to array buffer
								arrayBuf.Write(elemBuf.Bytes())
							}
							// Prepend length and decode using DecodeArray
							lengthBytes := protocol.EncodeInt32(length)
							fullData := append(lengthBytes, arrayBuf.Bytes()...)
							decoded, _, err := protocol.DecodeArray(fullData, decoder)
							if err != nil {
								return err
							}
							// Convert []interface{} to typed slice
							tempElem.CopartitionGroups = make([]StreamsGroupHeartbeatRequestCopartitionGroup, len(decoded))
							for i, item := range decoded {
								tempElem.CopartitionGroups[i] = item.(StreamsGroupHeartbeatRequestCopartitionGroup)
							}
						}
					}
					// SubtopologyId
					if version >= 0 && version <= 999 {
						if isFlexible {
							if err := protocol.WriteCompactString(elemW, tempElem.SubtopologyId); err != nil {
								return err
							}
						} else {
							if err := protocol.WriteString(elemW, tempElem.SubtopologyId); err != nil {
								return err
							}
						}
					}
					// SourceTopics
					if version >= 0 && version <= 999 {
						if isFlexible {
							if err := protocol.WriteCompactStringArray(elemW, tempElem.SourceTopics); err != nil {
								return err
							}
						} else {
							if err := protocol.WriteStringArray(elemW, tempElem.SourceTopics); err != nil {
								return err
							}
						}
					}
					// SourceTopicRegex
					if version >= 0 && version <= 999 {
						if isFlexible {
							if err := protocol.WriteCompactStringArray(elemW, tempElem.SourceTopicRegex); err != nil {
								return err
							}
						} else {
							if err := protocol.WriteStringArray(elemW, tempElem.SourceTopicRegex); err != nil {
								return err
							}
						}
					}
					// StateChangelogTopics
					if version >= 0 && version <= 999 {
						if isFlexible {
							length := uint32(len(tempElem.StateChangelogTopics) + 1)
							if err := protocol.WriteVaruint32(elemW, length); err != nil {
								return err
							}
						} else {
							if err := protocol.WriteInt32(elemW, int32(len(tempElem.StateChangelogTopics))); err != nil {
								return err
							}
						}
						for i := range tempElem.StateChangelogTopics {
							// Name
							if version >= 0 && version <= 999 {
								if isFlexible {
									if err := protocol.WriteCompactString(elemW, tempElem.StateChangelogTopics[i].Name); err != nil {
										return err
									}
								} else {
									if err := protocol.WriteString(elemW, tempElem.StateChangelogTopics[i].Name); err != nil {
										return err
									}
								}
							}
							// Partitions
							if version >= 0 && version <= 999 {
								if err := protocol.WriteInt32(elemW, tempElem.StateChangelogTopics[i].Partitions); err != nil {
									return err
								}
							}
							// ReplicationFactor
							if version >= 0 && version <= 999 {
								if err := protocol.WriteInt16(elemW, tempElem.StateChangelogTopics[i].ReplicationFactor); err != nil {
									return err
								}
							}
							// TopicConfigs
							if version >= 0 && version <= 999 {
								if isFlexible {
									length := uint32(len(tempElem.StateChangelogTopics[i].TopicConfigs) + 1)
									if err := protocol.WriteVaruint32(elemW, length); err != nil {
										return err
									}
								} else {
									if err := protocol.WriteInt32(elemW, int32(len(tempElem.StateChangelogTopics[i].TopicConfigs))); err != nil {
										return err
									}
								}
								for i := range tempElem.StateChangelogTopics[i].TopicConfigs {
									// Key
									if version >= 0 && version <= 999 {
										if isFlexible {
											if err := protocol.WriteCompactString(elemW, tempElem.StateChangelogTopics[i].TopicConfigs[i].Key); err != nil {
												return err
											}
										} else {
											if err := protocol.WriteString(elemW, tempElem.StateChangelogTopics[i].TopicConfigs[i].Key); err != nil {
												return err
											}
										}
									}
									// Value
									if version >= 0 && version <= 999 {
										if isFlexible {
											if err := protocol.WriteCompactString(elemW, tempElem.StateChangelogTopics[i].TopicConfigs[i].Value); err != nil {
												return err
											}
										} else {
											if err := protocol.WriteString(elemW, tempElem.StateChangelogTopics[i].TopicConfigs[i].Value); err != nil {
												return err
											}
										}
									}
								}
							}
						}
					}
					// RepartitionSinkTopics
					if version >= 0 && version <= 999 {
						if isFlexible {
							if err := protocol.WriteCompactStringArray(elemW, tempElem.RepartitionSinkTopics); err != nil {
								return err
							}
						} else {
							if err := protocol.WriteStringArray(elemW, tempElem.RepartitionSinkTopics); err != nil {
								return err
							}
						}
					}
					// RepartitionSourceTopics
					if version >= 0 && version <= 999 {
						if isFlexible {
							length := uint32(len(tempElem.RepartitionSourceTopics) + 1)
							if err := protocol.WriteVaruint32(elemW, length); err != nil {
								return err
							}
						} else {
							if err := protocol.WriteInt32(elemW, int32(len(tempElem.RepartitionSourceTopics))); err != nil {
								return err
							}
						}
						for i := range tempElem.RepartitionSourceTopics {
							// Name
							if version >= 0 && version <= 999 {
								if isFlexible {
									if err := protocol.WriteCompactString(elemW, tempElem.RepartitionSourceTopics[i].Name); err != nil {
										return err
									}
								} else {
									if err := protocol.WriteString(elemW, tempElem.RepartitionSourceTopics[i].Name); err != nil {
										return err
									}
								}
							}
							// Partitions
							if version >= 0 && version <= 999 {
								if err := protocol.WriteInt32(elemW, tempElem.RepartitionSourceTopics[i].Partitions); err != nil {
									return err
								}
							}
							// ReplicationFactor
							if version >= 0 && version <= 999 {
								if err := protocol.WriteInt16(elemW, tempElem.RepartitionSourceTopics[i].ReplicationFactor); err != nil {
									return err
								}
							}
							// TopicConfigs
							if version >= 0 && version <= 999 {
								if isFlexible {
									length := uint32(len(tempElem.RepartitionSourceTopics[i].TopicConfigs) + 1)
									if err := protocol.WriteVaruint32(elemW, length); err != nil {
										return err
									}
								} else {
									if err := protocol.WriteInt32(elemW, int32(len(tempElem.RepartitionSourceTopics[i].TopicConfigs))); err != nil {
										return err
									}
								}
								for i := range tempElem.RepartitionSourceTopics[i].TopicConfigs {
									// Key
									if version >= 0 && version <= 999 {
										if isFlexible {
											if err := protocol.WriteCompactString(elemW, tempElem.RepartitionSourceTopics[i].TopicConfigs[i].Key); err != nil {
												return err
											}
										} else {
											if err := protocol.WriteString(elemW, tempElem.RepartitionSourceTopics[i].TopicConfigs[i].Key); err != nil {
												return err
											}
										}
									}
									// Value
									if version >= 0 && version <= 999 {
										if isFlexible {
											if err := protocol.WriteCompactString(elemW, tempElem.RepartitionSourceTopics[i].TopicConfigs[i].Value); err != nil {
												return err
											}
										} else {
											if err := protocol.WriteString(elemW, tempElem.RepartitionSourceTopics[i].TopicConfigs[i].Value); err != nil {
												return err
											}
										}
									}
								}
							}
						}
					}
					// CopartitionGroups
					if version >= 0 && version <= 999 {
						if isFlexible {
							length := uint32(len(tempElem.CopartitionGroups) + 1)
							if err := protocol.WriteVaruint32(elemW, length); err != nil {
								return err
							}
						} else {
							if err := protocol.WriteInt32(elemW, int32(len(tempElem.CopartitionGroups))); err != nil {
								return err
							}
						}
						for i := range tempElem.CopartitionGroups {
							// SourceTopics
							if version >= 0 && version <= 999 {
								if isFlexible {
									if err := protocol.WriteCompactInt16Array(elemW, tempElem.CopartitionGroups[i].SourceTopics); err != nil {
										return err
									}
								} else {
									if err := protocol.WriteInt16Array(elemW, tempElem.CopartitionGroups[i].SourceTopics); err != nil {
										return err
									}
								}
							}
							// SourceTopicRegex
							if version >= 0 && version <= 999 {
								if isFlexible {
									if err := protocol.WriteCompactInt16Array(elemW, tempElem.CopartitionGroups[i].SourceTopicRegex); err != nil {
										return err
									}
								} else {
									if err := protocol.WriteInt16Array(elemW, tempElem.CopartitionGroups[i].SourceTopicRegex); err != nil {
										return err
									}
								}
							}
							// RepartitionSourceTopics
							if version >= 0 && version <= 999 {
								if isFlexible {
									if err := protocol.WriteCompactInt16Array(elemW, tempElem.CopartitionGroups[i].RepartitionSourceTopics); err != nil {
										return err
									}
								} else {
									if err := protocol.WriteInt16Array(elemW, tempElem.CopartitionGroups[i].RepartitionSourceTopics); err != nil {
										return err
									}
								}
							}
						}
					}
					// Append to array buffer
					arrayBuf.Write(elemBuf.Bytes())
				}
				// Prepend length and decode using DecodeArray
				lengthBytes := protocol.EncodeInt32(length)
				fullData := append(lengthBytes, arrayBuf.Bytes()...)
				decoded, _, err := protocol.DecodeArray(fullData, decoder)
				if err != nil {
					return err
				}
				// Convert []interface{} to typed slice
				m.Topology.Subtopologies = make([]StreamsGroupHeartbeatRequestSubtopology, len(decoded))
				for i, item := range decoded {
					m.Topology.Subtopologies[i] = item.(StreamsGroupHeartbeatRequestSubtopology)
				}
			}
		}
		// Read tagged fields if flexible
		if isFlexible {
			if err := m.Topology.readTaggedFields(r, version); err != nil {
				return err
			}
		}
	}
	// ActiveTasks
	if version >= 0 && version <= 999 {
		// Decode array using ArrayDecoder
		decoder := func(data []byte) (interface{}, int, error) {
			var elem TaskIds
			elemR := bytes.NewReader(data)
			// SubtopologyId
			if version >= 0 && version <= 999 {
				if isFlexible {
					val, err := protocol.ReadCompactString(elemR)
					if err != nil {
						return nil, 0, err
					}
					elem.SubtopologyId = val
				} else {
					val, err := protocol.ReadString(elemR)
					if err != nil {
						return nil, 0, err
					}
					elem.SubtopologyId = val
				}
			}
			// Partitions
			if version >= 0 && version <= 999 {
				if isFlexible {
					val, err := protocol.ReadCompactInt32Array(elemR)
					if err != nil {
						return nil, 0, err
					}
					elem.Partitions = val
				} else {
					val, err := protocol.ReadInt32Array(elemR)
					if err != nil {
						return nil, 0, err
					}
					elem.Partitions = val
				}
			}
			// Read tagged fields if flexible
			if isFlexible {
				if err := elem.readTaggedFields(elemR, version); err != nil {
					return nil, 0, err
				}
			}
			consumed := len(data) - elemR.Len()
			return elem, consumed, nil
		}
		if isFlexible {
			lengthUint, err := protocol.ReadVaruint32(r)
			if err != nil {
				return err
			}
			if lengthUint == 0 {
				m.ActiveTasks = nil
				return nil
			}
			if lengthUint < 1 {
				return errors.New("invalid compact array length")
			}
			length := int32(lengthUint - 1)
			// Collect all array elements into a buffer
			var arrayBuf bytes.Buffer
			for i := int32(0); i < length; i++ {
				// Read element into struct and encode to buffer
				var elemBuf bytes.Buffer
				elemW := &elemBuf
				var tempElem TaskIds
				// SubtopologyId
				if version >= 0 && version <= 999 {
					if isFlexible {
						val, err := protocol.ReadCompactString(r)
						if err != nil {
							return err
						}
						tempElem.SubtopologyId = val
					} else {
						val, err := protocol.ReadString(r)
						if err != nil {
							return err
						}
						tempElem.SubtopologyId = val
					}
				}
				// Partitions
				if version >= 0 && version <= 999 {
					if isFlexible {
						val, err := protocol.ReadCompactInt32Array(r)
						if err != nil {
							return err
						}
						tempElem.Partitions = val
					} else {
						val, err := protocol.ReadInt32Array(r)
						if err != nil {
							return err
						}
						tempElem.Partitions = val
					}
				}
				// SubtopologyId
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactString(elemW, tempElem.SubtopologyId); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteString(elemW, tempElem.SubtopologyId); err != nil {
							return err
						}
					}
				}
				// Partitions
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactInt32Array(elemW, tempElem.Partitions); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteInt32Array(elemW, tempElem.Partitions); err != nil {
							return err
						}
					}
				}
				// Append to array buffer
				arrayBuf.Write(elemBuf.Bytes())
			}
			// Prepend length and decode using DecodeCompactArray
			lengthBytes := protocol.EncodeVaruint32(lengthUint)
			fullData := append(lengthBytes, arrayBuf.Bytes()...)
			decoded, _, err := protocol.DecodeCompactArray(fullData, decoder)
			if err != nil {
				return err
			}
			// Convert []interface{} to typed slice
			m.ActiveTasks = make([]TaskIds, len(decoded))
			for i, item := range decoded {
				m.ActiveTasks[i] = item.(TaskIds)
			}
		} else {
			length, err := protocol.ReadInt32(r)
			if err != nil {
				return err
			}
			if length == -1 {
				m.ActiveTasks = nil
				return nil
			}
			// Collect all array elements into a buffer
			var arrayBuf bytes.Buffer
			for i := int32(0); i < length; i++ {
				// Read element into struct and encode to buffer
				var elemBuf bytes.Buffer
				elemW := &elemBuf
				var tempElem TaskIds
				// SubtopologyId
				if version >= 0 && version <= 999 {
					if isFlexible {
						val, err := protocol.ReadCompactString(r)
						if err != nil {
							return err
						}
						tempElem.SubtopologyId = val
					} else {
						val, err := protocol.ReadString(r)
						if err != nil {
							return err
						}
						tempElem.SubtopologyId = val
					}
				}
				// Partitions
				if version >= 0 && version <= 999 {
					if isFlexible {
						val, err := protocol.ReadCompactInt32Array(r)
						if err != nil {
							return err
						}
						tempElem.Partitions = val
					} else {
						val, err := protocol.ReadInt32Array(r)
						if err != nil {
							return err
						}
						tempElem.Partitions = val
					}
				}
				// SubtopologyId
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactString(elemW, tempElem.SubtopologyId); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteString(elemW, tempElem.SubtopologyId); err != nil {
							return err
						}
					}
				}
				// Partitions
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactInt32Array(elemW, tempElem.Partitions); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteInt32Array(elemW, tempElem.Partitions); err != nil {
							return err
						}
					}
				}
				// Append to array buffer
				arrayBuf.Write(elemBuf.Bytes())
			}
			// Prepend length and decode using DecodeArray
			lengthBytes := protocol.EncodeInt32(length)
			fullData := append(lengthBytes, arrayBuf.Bytes()...)
			decoded, _, err := protocol.DecodeArray(fullData, decoder)
			if err != nil {
				return err
			}
			// Convert []interface{} to typed slice
			m.ActiveTasks = make([]TaskIds, len(decoded))
			for i, item := range decoded {
				m.ActiveTasks[i] = item.(TaskIds)
			}
		}
	}
	// StandbyTasks
	if version >= 0 && version <= 999 {
		// Decode array using ArrayDecoder
		decoder := func(data []byte) (interface{}, int, error) {
			var elem TaskIds
			elemR := bytes.NewReader(data)
			// SubtopologyId
			if version >= 0 && version <= 999 {
				if isFlexible {
					val, err := protocol.ReadCompactString(elemR)
					if err != nil {
						return nil, 0, err
					}
					elem.SubtopologyId = val
				} else {
					val, err := protocol.ReadString(elemR)
					if err != nil {
						return nil, 0, err
					}
					elem.SubtopologyId = val
				}
			}
			// Partitions
			if version >= 0 && version <= 999 {
				if isFlexible {
					val, err := protocol.ReadCompactInt32Array(elemR)
					if err != nil {
						return nil, 0, err
					}
					elem.Partitions = val
				} else {
					val, err := protocol.ReadInt32Array(elemR)
					if err != nil {
						return nil, 0, err
					}
					elem.Partitions = val
				}
			}
			// Read tagged fields if flexible
			if isFlexible {
				if err := elem.readTaggedFields(elemR, version); err != nil {
					return nil, 0, err
				}
			}
			consumed := len(data) - elemR.Len()
			return elem, consumed, nil
		}
		if isFlexible {
			lengthUint, err := protocol.ReadVaruint32(r)
			if err != nil {
				return err
			}
			if lengthUint == 0 {
				m.StandbyTasks = nil
				return nil
			}
			if lengthUint < 1 {
				return errors.New("invalid compact array length")
			}
			length := int32(lengthUint - 1)
			// Collect all array elements into a buffer
			var arrayBuf bytes.Buffer
			for i := int32(0); i < length; i++ {
				// Read element into struct and encode to buffer
				var elemBuf bytes.Buffer
				elemW := &elemBuf
				var tempElem TaskIds
				// SubtopologyId
				if version >= 0 && version <= 999 {
					if isFlexible {
						val, err := protocol.ReadCompactString(r)
						if err != nil {
							return err
						}
						tempElem.SubtopologyId = val
					} else {
						val, err := protocol.ReadString(r)
						if err != nil {
							return err
						}
						tempElem.SubtopologyId = val
					}
				}
				// Partitions
				if version >= 0 && version <= 999 {
					if isFlexible {
						val, err := protocol.ReadCompactInt32Array(r)
						if err != nil {
							return err
						}
						tempElem.Partitions = val
					} else {
						val, err := protocol.ReadInt32Array(r)
						if err != nil {
							return err
						}
						tempElem.Partitions = val
					}
				}
				// SubtopologyId
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactString(elemW, tempElem.SubtopologyId); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteString(elemW, tempElem.SubtopologyId); err != nil {
							return err
						}
					}
				}
				// Partitions
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactInt32Array(elemW, tempElem.Partitions); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteInt32Array(elemW, tempElem.Partitions); err != nil {
							return err
						}
					}
				}
				// Append to array buffer
				arrayBuf.Write(elemBuf.Bytes())
			}
			// Prepend length and decode using DecodeCompactArray
			lengthBytes := protocol.EncodeVaruint32(lengthUint)
			fullData := append(lengthBytes, arrayBuf.Bytes()...)
			decoded, _, err := protocol.DecodeCompactArray(fullData, decoder)
			if err != nil {
				return err
			}
			// Convert []interface{} to typed slice
			m.StandbyTasks = make([]TaskIds, len(decoded))
			for i, item := range decoded {
				m.StandbyTasks[i] = item.(TaskIds)
			}
		} else {
			length, err := protocol.ReadInt32(r)
			if err != nil {
				return err
			}
			if length == -1 {
				m.StandbyTasks = nil
				return nil
			}
			// Collect all array elements into a buffer
			var arrayBuf bytes.Buffer
			for i := int32(0); i < length; i++ {
				// Read element into struct and encode to buffer
				var elemBuf bytes.Buffer
				elemW := &elemBuf
				var tempElem TaskIds
				// SubtopologyId
				if version >= 0 && version <= 999 {
					if isFlexible {
						val, err := protocol.ReadCompactString(r)
						if err != nil {
							return err
						}
						tempElem.SubtopologyId = val
					} else {
						val, err := protocol.ReadString(r)
						if err != nil {
							return err
						}
						tempElem.SubtopologyId = val
					}
				}
				// Partitions
				if version >= 0 && version <= 999 {
					if isFlexible {
						val, err := protocol.ReadCompactInt32Array(r)
						if err != nil {
							return err
						}
						tempElem.Partitions = val
					} else {
						val, err := protocol.ReadInt32Array(r)
						if err != nil {
							return err
						}
						tempElem.Partitions = val
					}
				}
				// SubtopologyId
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactString(elemW, tempElem.SubtopologyId); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteString(elemW, tempElem.SubtopologyId); err != nil {
							return err
						}
					}
				}
				// Partitions
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactInt32Array(elemW, tempElem.Partitions); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteInt32Array(elemW, tempElem.Partitions); err != nil {
							return err
						}
					}
				}
				// Append to array buffer
				arrayBuf.Write(elemBuf.Bytes())
			}
			// Prepend length and decode using DecodeArray
			lengthBytes := protocol.EncodeInt32(length)
			fullData := append(lengthBytes, arrayBuf.Bytes()...)
			decoded, _, err := protocol.DecodeArray(fullData, decoder)
			if err != nil {
				return err
			}
			// Convert []interface{} to typed slice
			m.StandbyTasks = make([]TaskIds, len(decoded))
			for i, item := range decoded {
				m.StandbyTasks[i] = item.(TaskIds)
			}
		}
	}
	// WarmupTasks
	if version >= 0 && version <= 999 {
		// Decode array using ArrayDecoder
		decoder := func(data []byte) (interface{}, int, error) {
			var elem TaskIds
			elemR := bytes.NewReader(data)
			// SubtopologyId
			if version >= 0 && version <= 999 {
				if isFlexible {
					val, err := protocol.ReadCompactString(elemR)
					if err != nil {
						return nil, 0, err
					}
					elem.SubtopologyId = val
				} else {
					val, err := protocol.ReadString(elemR)
					if err != nil {
						return nil, 0, err
					}
					elem.SubtopologyId = val
				}
			}
			// Partitions
			if version >= 0 && version <= 999 {
				if isFlexible {
					val, err := protocol.ReadCompactInt32Array(elemR)
					if err != nil {
						return nil, 0, err
					}
					elem.Partitions = val
				} else {
					val, err := protocol.ReadInt32Array(elemR)
					if err != nil {
						return nil, 0, err
					}
					elem.Partitions = val
				}
			}
			// Read tagged fields if flexible
			if isFlexible {
				if err := elem.readTaggedFields(elemR, version); err != nil {
					return nil, 0, err
				}
			}
			consumed := len(data) - elemR.Len()
			return elem, consumed, nil
		}
		if isFlexible {
			lengthUint, err := protocol.ReadVaruint32(r)
			if err != nil {
				return err
			}
			if lengthUint == 0 {
				m.WarmupTasks = nil
				return nil
			}
			if lengthUint < 1 {
				return errors.New("invalid compact array length")
			}
			length := int32(lengthUint - 1)
			// Collect all array elements into a buffer
			var arrayBuf bytes.Buffer
			for i := int32(0); i < length; i++ {
				// Read element into struct and encode to buffer
				var elemBuf bytes.Buffer
				elemW := &elemBuf
				var tempElem TaskIds
				// SubtopologyId
				if version >= 0 && version <= 999 {
					if isFlexible {
						val, err := protocol.ReadCompactString(r)
						if err != nil {
							return err
						}
						tempElem.SubtopologyId = val
					} else {
						val, err := protocol.ReadString(r)
						if err != nil {
							return err
						}
						tempElem.SubtopologyId = val
					}
				}
				// Partitions
				if version >= 0 && version <= 999 {
					if isFlexible {
						val, err := protocol.ReadCompactInt32Array(r)
						if err != nil {
							return err
						}
						tempElem.Partitions = val
					} else {
						val, err := protocol.ReadInt32Array(r)
						if err != nil {
							return err
						}
						tempElem.Partitions = val
					}
				}
				// SubtopologyId
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactString(elemW, tempElem.SubtopologyId); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteString(elemW, tempElem.SubtopologyId); err != nil {
							return err
						}
					}
				}
				// Partitions
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactInt32Array(elemW, tempElem.Partitions); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteInt32Array(elemW, tempElem.Partitions); err != nil {
							return err
						}
					}
				}
				// Append to array buffer
				arrayBuf.Write(elemBuf.Bytes())
			}
			// Prepend length and decode using DecodeCompactArray
			lengthBytes := protocol.EncodeVaruint32(lengthUint)
			fullData := append(lengthBytes, arrayBuf.Bytes()...)
			decoded, _, err := protocol.DecodeCompactArray(fullData, decoder)
			if err != nil {
				return err
			}
			// Convert []interface{} to typed slice
			m.WarmupTasks = make([]TaskIds, len(decoded))
			for i, item := range decoded {
				m.WarmupTasks[i] = item.(TaskIds)
			}
		} else {
			length, err := protocol.ReadInt32(r)
			if err != nil {
				return err
			}
			if length == -1 {
				m.WarmupTasks = nil
				return nil
			}
			// Collect all array elements into a buffer
			var arrayBuf bytes.Buffer
			for i := int32(0); i < length; i++ {
				// Read element into struct and encode to buffer
				var elemBuf bytes.Buffer
				elemW := &elemBuf
				var tempElem TaskIds
				// SubtopologyId
				if version >= 0 && version <= 999 {
					if isFlexible {
						val, err := protocol.ReadCompactString(r)
						if err != nil {
							return err
						}
						tempElem.SubtopologyId = val
					} else {
						val, err := protocol.ReadString(r)
						if err != nil {
							return err
						}
						tempElem.SubtopologyId = val
					}
				}
				// Partitions
				if version >= 0 && version <= 999 {
					if isFlexible {
						val, err := protocol.ReadCompactInt32Array(r)
						if err != nil {
							return err
						}
						tempElem.Partitions = val
					} else {
						val, err := protocol.ReadInt32Array(r)
						if err != nil {
							return err
						}
						tempElem.Partitions = val
					}
				}
				// SubtopologyId
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactString(elemW, tempElem.SubtopologyId); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteString(elemW, tempElem.SubtopologyId); err != nil {
							return err
						}
					}
				}
				// Partitions
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactInt32Array(elemW, tempElem.Partitions); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteInt32Array(elemW, tempElem.Partitions); err != nil {
							return err
						}
					}
				}
				// Append to array buffer
				arrayBuf.Write(elemBuf.Bytes())
			}
			// Prepend length and decode using DecodeArray
			lengthBytes := protocol.EncodeInt32(length)
			fullData := append(lengthBytes, arrayBuf.Bytes()...)
			decoded, _, err := protocol.DecodeArray(fullData, decoder)
			if err != nil {
				return err
			}
			// Convert []interface{} to typed slice
			m.WarmupTasks = make([]TaskIds, len(decoded))
			for i, item := range decoded {
				m.WarmupTasks[i] = item.(TaskIds)
			}
		}
	}
	// ProcessId
	if version >= 0 && version <= 999 {
		if isFlexible {
			val, err := protocol.ReadCompactNullableString(r)
			if err != nil {
				return err
			}
			m.ProcessId = val
		} else {
			val, err := protocol.ReadNullableString(r)
			if err != nil {
				return err
			}
			m.ProcessId = val
		}
	}
	// UserEndpoint
	if version >= 0 && version <= 999 {
	}
	// ClientTags
	if version >= 0 && version <= 999 {
		// Decode array using ArrayDecoder
		decoder := func(data []byte) (interface{}, int, error) {
			var elem KeyValue
			elemR := bytes.NewReader(data)
			// Key
			if version >= 0 && version <= 999 {
				if isFlexible {
					val, err := protocol.ReadCompactString(elemR)
					if err != nil {
						return nil, 0, err
					}
					elem.Key = val
				} else {
					val, err := protocol.ReadString(elemR)
					if err != nil {
						return nil, 0, err
					}
					elem.Key = val
				}
			}
			// Value
			if version >= 0 && version <= 999 {
				if isFlexible {
					val, err := protocol.ReadCompactString(elemR)
					if err != nil {
						return nil, 0, err
					}
					elem.Value = val
				} else {
					val, err := protocol.ReadString(elemR)
					if err != nil {
						return nil, 0, err
					}
					elem.Value = val
				}
			}
			// Read tagged fields if flexible
			if isFlexible {
				if err := elem.readTaggedFields(elemR, version); err != nil {
					return nil, 0, err
				}
			}
			consumed := len(data) - elemR.Len()
			return elem, consumed, nil
		}
		if isFlexible {
			lengthUint, err := protocol.ReadVaruint32(r)
			if err != nil {
				return err
			}
			if lengthUint == 0 {
				m.ClientTags = nil
				return nil
			}
			if lengthUint < 1 {
				return errors.New("invalid compact array length")
			}
			length := int32(lengthUint - 1)
			// Collect all array elements into a buffer
			var arrayBuf bytes.Buffer
			for i := int32(0); i < length; i++ {
				// Read element into struct and encode to buffer
				var elemBuf bytes.Buffer
				elemW := &elemBuf
				var tempElem KeyValue
				// Key
				if version >= 0 && version <= 999 {
					if isFlexible {
						val, err := protocol.ReadCompactString(r)
						if err != nil {
							return err
						}
						tempElem.Key = val
					} else {
						val, err := protocol.ReadString(r)
						if err != nil {
							return err
						}
						tempElem.Key = val
					}
				}
				// Value
				if version >= 0 && version <= 999 {
					if isFlexible {
						val, err := protocol.ReadCompactString(r)
						if err != nil {
							return err
						}
						tempElem.Value = val
					} else {
						val, err := protocol.ReadString(r)
						if err != nil {
							return err
						}
						tempElem.Value = val
					}
				}
				// Key
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactString(elemW, tempElem.Key); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteString(elemW, tempElem.Key); err != nil {
							return err
						}
					}
				}
				// Value
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactString(elemW, tempElem.Value); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteString(elemW, tempElem.Value); err != nil {
							return err
						}
					}
				}
				// Append to array buffer
				arrayBuf.Write(elemBuf.Bytes())
			}
			// Prepend length and decode using DecodeCompactArray
			lengthBytes := protocol.EncodeVaruint32(lengthUint)
			fullData := append(lengthBytes, arrayBuf.Bytes()...)
			decoded, _, err := protocol.DecodeCompactArray(fullData, decoder)
			if err != nil {
				return err
			}
			// Convert []interface{} to typed slice
			m.ClientTags = make([]KeyValue, len(decoded))
			for i, item := range decoded {
				m.ClientTags[i] = item.(KeyValue)
			}
		} else {
			length, err := protocol.ReadInt32(r)
			if err != nil {
				return err
			}
			if length == -1 {
				m.ClientTags = nil
				return nil
			}
			// Collect all array elements into a buffer
			var arrayBuf bytes.Buffer
			for i := int32(0); i < length; i++ {
				// Read element into struct and encode to buffer
				var elemBuf bytes.Buffer
				elemW := &elemBuf
				var tempElem KeyValue
				// Key
				if version >= 0 && version <= 999 {
					if isFlexible {
						val, err := protocol.ReadCompactString(r)
						if err != nil {
							return err
						}
						tempElem.Key = val
					} else {
						val, err := protocol.ReadString(r)
						if err != nil {
							return err
						}
						tempElem.Key = val
					}
				}
				// Value
				if version >= 0 && version <= 999 {
					if isFlexible {
						val, err := protocol.ReadCompactString(r)
						if err != nil {
							return err
						}
						tempElem.Value = val
					} else {
						val, err := protocol.ReadString(r)
						if err != nil {
							return err
						}
						tempElem.Value = val
					}
				}
				// Key
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactString(elemW, tempElem.Key); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteString(elemW, tempElem.Key); err != nil {
							return err
						}
					}
				}
				// Value
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactString(elemW, tempElem.Value); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteString(elemW, tempElem.Value); err != nil {
							return err
						}
					}
				}
				// Append to array buffer
				arrayBuf.Write(elemBuf.Bytes())
			}
			// Prepend length and decode using DecodeArray
			lengthBytes := protocol.EncodeInt32(length)
			fullData := append(lengthBytes, arrayBuf.Bytes()...)
			decoded, _, err := protocol.DecodeArray(fullData, decoder)
			if err != nil {
				return err
			}
			// Convert []interface{} to typed slice
			m.ClientTags = make([]KeyValue, len(decoded))
			for i, item := range decoded {
				m.ClientTags[i] = item.(KeyValue)
			}
		}
	}
	// TaskOffsets
	if version >= 0 && version <= 999 {
		// Decode array using ArrayDecoder
		decoder := func(data []byte) (interface{}, int, error) {
			var elem TaskOffset
			elemR := bytes.NewReader(data)
			// SubtopologyId
			if version >= 0 && version <= 999 {
				if isFlexible {
					val, err := protocol.ReadCompactString(elemR)
					if err != nil {
						return nil, 0, err
					}
					elem.SubtopologyId = val
				} else {
					val, err := protocol.ReadString(elemR)
					if err != nil {
						return nil, 0, err
					}
					elem.SubtopologyId = val
				}
			}
			// Partition
			if version >= 0 && version <= 999 {
				val, err := protocol.ReadInt32(elemR)
				if err != nil {
					return nil, 0, err
				}
				elem.Partition = val
			}
			// Offset
			if version >= 0 && version <= 999 {
				val, err := protocol.ReadInt64(elemR)
				if err != nil {
					return nil, 0, err
				}
				elem.Offset = val
			}
			// Read tagged fields if flexible
			if isFlexible {
				if err := elem.readTaggedFields(elemR, version); err != nil {
					return nil, 0, err
				}
			}
			consumed := len(data) - elemR.Len()
			return elem, consumed, nil
		}
		if isFlexible {
			lengthUint, err := protocol.ReadVaruint32(r)
			if err != nil {
				return err
			}
			if lengthUint == 0 {
				m.TaskOffsets = nil
				return nil
			}
			if lengthUint < 1 {
				return errors.New("invalid compact array length")
			}
			length := int32(lengthUint - 1)
			// Collect all array elements into a buffer
			var arrayBuf bytes.Buffer
			for i := int32(0); i < length; i++ {
				// Read element into struct and encode to buffer
				var elemBuf bytes.Buffer
				elemW := &elemBuf
				var tempElem TaskOffset
				// SubtopologyId
				if version >= 0 && version <= 999 {
					if isFlexible {
						val, err := protocol.ReadCompactString(r)
						if err != nil {
							return err
						}
						tempElem.SubtopologyId = val
					} else {
						val, err := protocol.ReadString(r)
						if err != nil {
							return err
						}
						tempElem.SubtopologyId = val
					}
				}
				// Partition
				if version >= 0 && version <= 999 {
					val, err := protocol.ReadInt32(r)
					if err != nil {
						return err
					}
					tempElem.Partition = val
				}
				// Offset
				if version >= 0 && version <= 999 {
					val, err := protocol.ReadInt64(r)
					if err != nil {
						return err
					}
					tempElem.Offset = val
				}
				// SubtopologyId
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactString(elemW, tempElem.SubtopologyId); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteString(elemW, tempElem.SubtopologyId); err != nil {
							return err
						}
					}
				}
				// Partition
				if version >= 0 && version <= 999 {
					if err := protocol.WriteInt32(elemW, tempElem.Partition); err != nil {
						return err
					}
				}
				// Offset
				if version >= 0 && version <= 999 {
					if err := protocol.WriteInt64(elemW, tempElem.Offset); err != nil {
						return err
					}
				}
				// Append to array buffer
				arrayBuf.Write(elemBuf.Bytes())
			}
			// Prepend length and decode using DecodeCompactArray
			lengthBytes := protocol.EncodeVaruint32(lengthUint)
			fullData := append(lengthBytes, arrayBuf.Bytes()...)
			decoded, _, err := protocol.DecodeCompactArray(fullData, decoder)
			if err != nil {
				return err
			}
			// Convert []interface{} to typed slice
			m.TaskOffsets = make([]TaskOffset, len(decoded))
			for i, item := range decoded {
				m.TaskOffsets[i] = item.(TaskOffset)
			}
		} else {
			length, err := protocol.ReadInt32(r)
			if err != nil {
				return err
			}
			if length == -1 {
				m.TaskOffsets = nil
				return nil
			}
			// Collect all array elements into a buffer
			var arrayBuf bytes.Buffer
			for i := int32(0); i < length; i++ {
				// Read element into struct and encode to buffer
				var elemBuf bytes.Buffer
				elemW := &elemBuf
				var tempElem TaskOffset
				// SubtopologyId
				if version >= 0 && version <= 999 {
					if isFlexible {
						val, err := protocol.ReadCompactString(r)
						if err != nil {
							return err
						}
						tempElem.SubtopologyId = val
					} else {
						val, err := protocol.ReadString(r)
						if err != nil {
							return err
						}
						tempElem.SubtopologyId = val
					}
				}
				// Partition
				if version >= 0 && version <= 999 {
					val, err := protocol.ReadInt32(r)
					if err != nil {
						return err
					}
					tempElem.Partition = val
				}
				// Offset
				if version >= 0 && version <= 999 {
					val, err := protocol.ReadInt64(r)
					if err != nil {
						return err
					}
					tempElem.Offset = val
				}
				// SubtopologyId
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactString(elemW, tempElem.SubtopologyId); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteString(elemW, tempElem.SubtopologyId); err != nil {
							return err
						}
					}
				}
				// Partition
				if version >= 0 && version <= 999 {
					if err := protocol.WriteInt32(elemW, tempElem.Partition); err != nil {
						return err
					}
				}
				// Offset
				if version >= 0 && version <= 999 {
					if err := protocol.WriteInt64(elemW, tempElem.Offset); err != nil {
						return err
					}
				}
				// Append to array buffer
				arrayBuf.Write(elemBuf.Bytes())
			}
			// Prepend length and decode using DecodeArray
			lengthBytes := protocol.EncodeInt32(length)
			fullData := append(lengthBytes, arrayBuf.Bytes()...)
			decoded, _, err := protocol.DecodeArray(fullData, decoder)
			if err != nil {
				return err
			}
			// Convert []interface{} to typed slice
			m.TaskOffsets = make([]TaskOffset, len(decoded))
			for i, item := range decoded {
				m.TaskOffsets[i] = item.(TaskOffset)
			}
		}
	}
	// TaskEndOffsets
	if version >= 0 && version <= 999 {
		// Decode array using ArrayDecoder
		decoder := func(data []byte) (interface{}, int, error) {
			var elem TaskOffset
			elemR := bytes.NewReader(data)
			// SubtopologyId
			if version >= 0 && version <= 999 {
				if isFlexible {
					val, err := protocol.ReadCompactString(elemR)
					if err != nil {
						return nil, 0, err
					}
					elem.SubtopologyId = val
				} else {
					val, err := protocol.ReadString(elemR)
					if err != nil {
						return nil, 0, err
					}
					elem.SubtopologyId = val
				}
			}
			// Partition
			if version >= 0 && version <= 999 {
				val, err := protocol.ReadInt32(elemR)
				if err != nil {
					return nil, 0, err
				}
				elem.Partition = val
			}
			// Offset
			if version >= 0 && version <= 999 {
				val, err := protocol.ReadInt64(elemR)
				if err != nil {
					return nil, 0, err
				}
				elem.Offset = val
			}
			// Read tagged fields if flexible
			if isFlexible {
				if err := elem.readTaggedFields(elemR, version); err != nil {
					return nil, 0, err
				}
			}
			consumed := len(data) - elemR.Len()
			return elem, consumed, nil
		}
		if isFlexible {
			lengthUint, err := protocol.ReadVaruint32(r)
			if err != nil {
				return err
			}
			if lengthUint == 0 {
				m.TaskEndOffsets = nil
				return nil
			}
			if lengthUint < 1 {
				return errors.New("invalid compact array length")
			}
			length := int32(lengthUint - 1)
			// Collect all array elements into a buffer
			var arrayBuf bytes.Buffer
			for i := int32(0); i < length; i++ {
				// Read element into struct and encode to buffer
				var elemBuf bytes.Buffer
				elemW := &elemBuf
				var tempElem TaskOffset
				// SubtopologyId
				if version >= 0 && version <= 999 {
					if isFlexible {
						val, err := protocol.ReadCompactString(r)
						if err != nil {
							return err
						}
						tempElem.SubtopologyId = val
					} else {
						val, err := protocol.ReadString(r)
						if err != nil {
							return err
						}
						tempElem.SubtopologyId = val
					}
				}
				// Partition
				if version >= 0 && version <= 999 {
					val, err := protocol.ReadInt32(r)
					if err != nil {
						return err
					}
					tempElem.Partition = val
				}
				// Offset
				if version >= 0 && version <= 999 {
					val, err := protocol.ReadInt64(r)
					if err != nil {
						return err
					}
					tempElem.Offset = val
				}
				// SubtopologyId
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactString(elemW, tempElem.SubtopologyId); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteString(elemW, tempElem.SubtopologyId); err != nil {
							return err
						}
					}
				}
				// Partition
				if version >= 0 && version <= 999 {
					if err := protocol.WriteInt32(elemW, tempElem.Partition); err != nil {
						return err
					}
				}
				// Offset
				if version >= 0 && version <= 999 {
					if err := protocol.WriteInt64(elemW, tempElem.Offset); err != nil {
						return err
					}
				}
				// Append to array buffer
				arrayBuf.Write(elemBuf.Bytes())
			}
			// Prepend length and decode using DecodeCompactArray
			lengthBytes := protocol.EncodeVaruint32(lengthUint)
			fullData := append(lengthBytes, arrayBuf.Bytes()...)
			decoded, _, err := protocol.DecodeCompactArray(fullData, decoder)
			if err != nil {
				return err
			}
			// Convert []interface{} to typed slice
			m.TaskEndOffsets = make([]TaskOffset, len(decoded))
			for i, item := range decoded {
				m.TaskEndOffsets[i] = item.(TaskOffset)
			}
		} else {
			length, err := protocol.ReadInt32(r)
			if err != nil {
				return err
			}
			if length == -1 {
				m.TaskEndOffsets = nil
				return nil
			}
			// Collect all array elements into a buffer
			var arrayBuf bytes.Buffer
			for i := int32(0); i < length; i++ {
				// Read element into struct and encode to buffer
				var elemBuf bytes.Buffer
				elemW := &elemBuf
				var tempElem TaskOffset
				// SubtopologyId
				if version >= 0 && version <= 999 {
					if isFlexible {
						val, err := protocol.ReadCompactString(r)
						if err != nil {
							return err
						}
						tempElem.SubtopologyId = val
					} else {
						val, err := protocol.ReadString(r)
						if err != nil {
							return err
						}
						tempElem.SubtopologyId = val
					}
				}
				// Partition
				if version >= 0 && version <= 999 {
					val, err := protocol.ReadInt32(r)
					if err != nil {
						return err
					}
					tempElem.Partition = val
				}
				// Offset
				if version >= 0 && version <= 999 {
					val, err := protocol.ReadInt64(r)
					if err != nil {
						return err
					}
					tempElem.Offset = val
				}
				// SubtopologyId
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactString(elemW, tempElem.SubtopologyId); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteString(elemW, tempElem.SubtopologyId); err != nil {
							return err
						}
					}
				}
				// Partition
				if version >= 0 && version <= 999 {
					if err := protocol.WriteInt32(elemW, tempElem.Partition); err != nil {
						return err
					}
				}
				// Offset
				if version >= 0 && version <= 999 {
					if err := protocol.WriteInt64(elemW, tempElem.Offset); err != nil {
						return err
					}
				}
				// Append to array buffer
				arrayBuf.Write(elemBuf.Bytes())
			}
			// Prepend length and decode using DecodeArray
			lengthBytes := protocol.EncodeInt32(length)
			fullData := append(lengthBytes, arrayBuf.Bytes()...)
			decoded, _, err := protocol.DecodeArray(fullData, decoder)
			if err != nil {
				return err
			}
			// Convert []interface{} to typed slice
			m.TaskEndOffsets = make([]TaskOffset, len(decoded))
			for i, item := range decoded {
				m.TaskEndOffsets[i] = item.(TaskOffset)
			}
		}
	}
	// ShutdownApplication
	if version >= 0 && version <= 999 {
		val, err := protocol.ReadBool(r)
		if err != nil {
			return err
		}
		m.ShutdownApplication = val
	}
	// Read tagged fields if flexible
	if isFlexible {
		if err := m.readTaggedFields(r, version); err != nil {
			return err
		}
	}
	return nil
}

// StreamsGroupHeartbeatRequestTopology represents The topology metadata of the streams application. Used to initialize the topology of the group and to check if the topology corresponds to the topology initialized for the group. Only sent when memberEpoch = 0, must be non-empty. Null otherwise..
type StreamsGroupHeartbeatRequestTopology struct {
	// The epoch of the topology. Used to check if the topology corresponds to the topology initialized on the brokers.
	Epoch int32 `json:"epoch" versions:"0-999"`
	// The sub-topologies of the streams application.
	Subtopologies []StreamsGroupHeartbeatRequestSubtopology `json:"subtopologies" versions:"0-999"`
	// Tagged fields (for flexible versions)
	_tagged_fields map[uint32]interface{} `json:"-"`
}

// writeTaggedFields writes tagged fields for StreamsGroupHeartbeatRequestTopology.
func (m *StreamsGroupHeartbeatRequestTopology) writeTaggedFields(w io.Writer, version int16) error {
	var taggedFieldsCount int
	var taggedFieldsBuf bytes.Buffer

	// Write tagged fields count
	if err := protocol.WriteVaruint32(w, uint32(taggedFieldsCount)); err != nil {
		return err
	}

	// Write tagged fields data
	if taggedFieldsCount > 0 {
		if _, err := w.Write(taggedFieldsBuf.Bytes()); err != nil {
			return err
		}
	}

	return nil
}

// readTaggedFields reads tagged fields for StreamsGroupHeartbeatRequestTopology.
func (m *StreamsGroupHeartbeatRequestTopology) readTaggedFields(r io.Reader, version int16) error {
	// Read tagged fields count
	count, err := protocol.ReadVaruint32(r)
	if err != nil {
		return err
	}

	if count == 0 {
		return nil
	}

	// Read tagged fields
	for i := uint32(0); i < count; i++ {
		tag, err := protocol.ReadVaruint32(r)
		if err != nil {
			return err
		}

		switch tag {
		default:
			// Unknown tag, skip it
		}
	}

	return nil
}

// StreamsGroupHeartbeatRequestSubtopology represents The sub-topologies of the streams application..
type StreamsGroupHeartbeatRequestSubtopology struct {
	// String to uniquely identify the subtopology. Deterministically generated from the topology
	SubtopologyId string `json:"subtopologyid" versions:"0-999"`
	// The topics the topology reads from.
	SourceTopics []string `json:"sourcetopics" versions:"0-999"`
	// The regular expressions identifying topics the subtopology reads from.
	SourceTopicRegex []string `json:"sourcetopicregex" versions:"0-999"`
	// The set of state changelog topics associated with this subtopology. Created automatically.
	StateChangelogTopics []TopicInfo `json:"statechangelogtopics" versions:"0-999"`
	// The repartition topics the subtopology writes to.
	RepartitionSinkTopics []string `json:"repartitionsinktopics" versions:"0-999"`
	// The set of source topics that are internally created repartition topics. Created automatically.
	RepartitionSourceTopics []TopicInfo `json:"repartitionsourcetopics" versions:"0-999"`
	// A subset of source topics that must be copartitioned.
	CopartitionGroups []StreamsGroupHeartbeatRequestCopartitionGroup `json:"copartitiongroups" versions:"0-999"`
	// Tagged fields (for flexible versions)
	_tagged_fields map[uint32]interface{} `json:"-"`
}

// writeTaggedFields writes tagged fields for StreamsGroupHeartbeatRequestSubtopology.
func (m *StreamsGroupHeartbeatRequestSubtopology) writeTaggedFields(w io.Writer, version int16) error {
	var taggedFieldsCount int
	var taggedFieldsBuf bytes.Buffer

	// Write tagged fields count
	if err := protocol.WriteVaruint32(w, uint32(taggedFieldsCount)); err != nil {
		return err
	}

	// Write tagged fields data
	if taggedFieldsCount > 0 {
		if _, err := w.Write(taggedFieldsBuf.Bytes()); err != nil {
			return err
		}
	}

	return nil
}

// readTaggedFields reads tagged fields for StreamsGroupHeartbeatRequestSubtopology.
func (m *StreamsGroupHeartbeatRequestSubtopology) readTaggedFields(r io.Reader, version int16) error {
	// Read tagged fields count
	count, err := protocol.ReadVaruint32(r)
	if err != nil {
		return err
	}

	if count == 0 {
		return nil
	}

	// Read tagged fields
	for i := uint32(0); i < count; i++ {
		tag, err := protocol.ReadVaruint32(r)
		if err != nil {
			return err
		}

		switch tag {
		default:
			// Unknown tag, skip it
		}
	}

	return nil
}

// StreamsGroupHeartbeatRequestCopartitionGroup represents A subset of source topics that must be copartitioned..
type StreamsGroupHeartbeatRequestCopartitionGroup struct {
	// The topics the topology reads from. Index into the array on the subtopology level.
	SourceTopics []int16 `json:"sourcetopics" versions:"0-999"`
	// Regular expressions identifying topics the subtopology reads from. Index into the array on the subtopology level.
	SourceTopicRegex []int16 `json:"sourcetopicregex" versions:"0-999"`
	// The set of source topics that are internally created repartition topics. Index into the array on the subtopology level.
	RepartitionSourceTopics []int16 `json:"repartitionsourcetopics" versions:"0-999"`
	// Tagged fields (for flexible versions)
	_tagged_fields map[uint32]interface{} `json:"-"`
}

// writeTaggedFields writes tagged fields for StreamsGroupHeartbeatRequestCopartitionGroup.
func (m *StreamsGroupHeartbeatRequestCopartitionGroup) writeTaggedFields(w io.Writer, version int16) error {
	var taggedFieldsCount int
	var taggedFieldsBuf bytes.Buffer

	// Write tagged fields count
	if err := protocol.WriteVaruint32(w, uint32(taggedFieldsCount)); err != nil {
		return err
	}

	// Write tagged fields data
	if taggedFieldsCount > 0 {
		if _, err := w.Write(taggedFieldsBuf.Bytes()); err != nil {
			return err
		}
	}

	return nil
}

// readTaggedFields reads tagged fields for StreamsGroupHeartbeatRequestCopartitionGroup.
func (m *StreamsGroupHeartbeatRequestCopartitionGroup) readTaggedFields(r io.Reader, version int16) error {
	// Read tagged fields count
	count, err := protocol.ReadVaruint32(r)
	if err != nil {
		return err
	}

	if count == 0 {
		return nil
	}

	// Read tagged fields
	for i := uint32(0); i < count; i++ {
		tag, err := protocol.ReadVaruint32(r)
		if err != nil {
			return err
		}

		switch tag {
		default:
			// Unknown tag, skip it
		}
	}

	return nil
}

// KeyValue represents .
type KeyValue struct {
	// key of the config
	Key string `json:"key" versions:"0-999"`
	// value of the config
	Value string `json:"value" versions:"0-999"`
}

// TopicInfo represents .
type TopicInfo struct {
	// The name of the topic.
	Name string `json:"name" versions:"0-999"`
	// The number of partitions in the topic. Can be 0 if no specific number of partitions is enforced. Always 0 for changelog topics.
	Partitions int32 `json:"partitions" versions:"0-999"`
	// The replication factor of the topic. Can be 0 if the default replication factor should be used.
	ReplicationFactor int16 `json:"replicationfactor" versions:"0-999"`
	// Topic-level configurations as key-value pairs.
	TopicConfigs []KeyValue `json:"topicconfigs" versions:"0-999"`
}

// Endpoint represents .
type Endpoint struct {
	// host of the endpoint
	Host string `json:"host" versions:"0-999"`
	// port of the endpoint
	Port uint16 `json:"port" versions:"0-999"`
}

// TaskOffset represents .
type TaskOffset struct {
	// The subtopology identifier.
	SubtopologyId string `json:"subtopologyid" versions:"0-999"`
	// The partition.
	Partition int32 `json:"partition" versions:"0-999"`
	// The offset.
	Offset int64 `json:"offset" versions:"0-999"`
}

// TaskIds represents .
type TaskIds struct {
	// The subtopology identifier.
	SubtopologyId string `json:"subtopologyid" versions:"0-999"`
	// The partitions of the input topics processed by this member.
	Partitions []int32 `json:"partitions" versions:"0-999"`
}

// Status represents .
type Status struct {
	// A code to indicate that a particular status is active for the group membership
	StatusCode int8 `json:"statuscode" versions:"0-999"`
	// A string representation of the status.
	StatusDetail string `json:"statusdetail" versions:"0-999"`
}

// TopicPartition represents .
type TopicPartition struct {
	// topic name
	Topic string `json:"topic" versions:"0-999"`
	// partitions
	Partitions []int32 `json:"partitions" versions:"0-999"`
}

// writeTaggedFields writes tagged fields for StreamsGroupHeartbeatRequest.
func (m *StreamsGroupHeartbeatRequest) writeTaggedFields(w io.Writer, version int16) error {
	var taggedFieldsCount int
	var taggedFieldsBuf bytes.Buffer

	// Write tagged fields count
	if err := protocol.WriteVaruint32(w, uint32(taggedFieldsCount)); err != nil {
		return err
	}

	// Write tagged fields data
	if taggedFieldsCount > 0 {
		if _, err := w.Write(taggedFieldsBuf.Bytes()); err != nil {
			return err
		}
	}

	return nil
}

// readTaggedFields reads tagged fields for StreamsGroupHeartbeatRequest.
func (m *StreamsGroupHeartbeatRequest) readTaggedFields(r io.Reader, version int16) error {
	// Read tagged fields count
	count, err := protocol.ReadVaruint32(r)
	if err != nil {
		return err
	}

	if count == 0 {
		return nil
	}

	// Read tagged fields
	for i := uint32(0); i < count; i++ {
		tag, err := protocol.ReadVaruint32(r)
		if err != nil {
			return err
		}

		switch tag {
		default:
			// Unknown tag, skip it
			// Read and discard the field data
			// For now, we'll need to know the type to skip properly
			// This is a simplified implementation
		}
	}

	return nil
}

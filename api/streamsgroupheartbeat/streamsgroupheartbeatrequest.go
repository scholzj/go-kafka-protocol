package streamsgroupheartbeat

import (
	"bytes"
	"errors"
	"io"

	"github.com/scholzj/go-kafka-protocol/protocol"
)

const (
	StreamsGroupHeartbeatRequestApiKey        = 88
	StreamsGroupHeartbeatRequestHeaderVersion = 1
)

// StreamsGroupHeartbeatRequest represents a request message.
type StreamsGroupHeartbeatRequest struct {
	// The group identifier.
	GroupId string `json:"groupid" versions:"0-999"`
	// The member ID generated by the streams consumer. The member ID must be kept during the entire lifetime of the streams consumer process.
	MemberId string `json:"memberid" versions:"0-999"`
	// The current member epoch; 0 to join the group; -1 to leave the group; -2 to indicate that the static member will rejoin.
	MemberEpoch int32 `json:"memberepoch" versions:"0-999"`
	// The current endpoint epoch of this client, represents the latest endpoint epoch this client received
	EndpointInformationEpoch int32 `json:"endpointinformationepoch" versions:"0-999"`
	// null if not provided or if it didn't change since the last heartbeat; the instance ID for static membership otherwise.
	InstanceId *string `json:"instanceid" versions:"0-999"`
	// null if not provided or if it didn't change since the last heartbeat; the rack ID of the member otherwise.
	RackId *string `json:"rackid" versions:"0-999"`
	// -1 if it didn't change since the last heartbeat; the maximum time in milliseconds that the coordinator will wait on the member to revoke its tasks otherwise.
	RebalanceTimeoutMs int32 `json:"rebalancetimeoutms" versions:"0-999"`
	// The topology metadata of the streams application. Used to initialize the topology of the group and to check if the topology corresponds to the topology initialized for the group. Only sent when memberEpoch = 0, must be non-empty. Null otherwise.
	Topology StreamsGroupHeartbeatRequestTopology `json:"topology" versions:"0-999"`
	// Currently owned active tasks for this client. Null if unchanged since last heartbeat.
	ActiveTasks []TaskIds `json:"activetasks" versions:"0-999"`
	// Currently owned standby tasks for this client. Null if unchanged since last heartbeat.
	StandbyTasks []TaskIds `json:"standbytasks" versions:"0-999"`
	// Currently owned warm-up tasks for this client. Null if unchanged since last heartbeat.
	WarmupTasks []TaskIds `json:"warmuptasks" versions:"0-999"`
	// Identity of the streams instance that may have multiple consumers. Null if unchanged since last heartbeat.
	ProcessId *string `json:"processid" versions:"0-999"`
	// User-defined endpoint for Interactive Queries. Null if unchanged since last heartbeat, or if not defined on the client.
	UserEndpoint Endpoint `json:"userendpoint" versions:"0-999"`
	// Used for rack-aware assignment algorithm. Null if unchanged since last heartbeat.
	ClientTags []KeyValue `json:"clienttags" versions:"0-999"`
	// Cumulative changelog offsets for tasks. Only updated when a warm-up task has caught up, and according to the task offset interval. Null if unchanged since last heartbeat.
	TaskOffsets []TaskOffset `json:"taskoffsets" versions:"0-999"`
	// Cumulative changelog end-offsets for tasks. Only updated when a warm-up task has caught up, and according to the task offset interval. Null if unchanged since last heartbeat.
	TaskEndOffsets []TaskOffset `json:"taskendoffsets" versions:"0-999"`
	// Whether all Streams clients in the group should shut down.
	ShutdownApplication bool `json:"shutdownapplication" versions:"0-999"`
}

// Encode encodes a StreamsGroupHeartbeatRequest to a byte slice for the given version.
func (m *StreamsGroupHeartbeatRequest) Encode(version int16) ([]byte, error) {
	var buf bytes.Buffer
	if err := m.Write(&buf, version); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// Decode decodes a StreamsGroupHeartbeatRequest from a byte slice for the given version.
func (m *StreamsGroupHeartbeatRequest) Decode(data []byte, version int16) error {
	r := bytes.NewReader(data)
	return m.Read(r, version)
}

// Write writes a StreamsGroupHeartbeatRequest to an io.Writer for the given version.
func (m *StreamsGroupHeartbeatRequest) Write(w io.Writer, version int16) error {
	if version < 0 || version > 0 {
		return errors.New("unsupported version")
	}

	isFlexible := false
	if version >= 0 {
		isFlexible = true
	}

	// GroupId
	if version >= 0 && version <= 999 {
		if isFlexible {
			if err := protocol.WriteCompactString(w, m.GroupId); err != nil {
				return err
			}
		} else {
			if err := protocol.WriteString(w, m.GroupId); err != nil {
				return err
			}
		}
	}
	// MemberId
	if version >= 0 && version <= 999 {
		if isFlexible {
			if err := protocol.WriteCompactString(w, m.MemberId); err != nil {
				return err
			}
		} else {
			if err := protocol.WriteString(w, m.MemberId); err != nil {
				return err
			}
		}
	}
	// MemberEpoch
	if version >= 0 && version <= 999 {
		if err := protocol.WriteInt32(w, m.MemberEpoch); err != nil {
			return err
		}
	}
	// EndpointInformationEpoch
	if version >= 0 && version <= 999 {
		if err := protocol.WriteInt32(w, m.EndpointInformationEpoch); err != nil {
			return err
		}
	}
	// InstanceId
	if version >= 0 && version <= 999 {
		if isFlexible {
			if err := protocol.WriteCompactNullableString(w, m.InstanceId); err != nil {
				return err
			}
		} else {
			if err := protocol.WriteNullableString(w, m.InstanceId); err != nil {
				return err
			}
		}
	}
	// RackId
	if version >= 0 && version <= 999 {
		if isFlexible {
			if err := protocol.WriteCompactNullableString(w, m.RackId); err != nil {
				return err
			}
		} else {
			if err := protocol.WriteNullableString(w, m.RackId); err != nil {
				return err
			}
		}
	}
	// RebalanceTimeoutMs
	if version >= 0 && version <= 999 {
		if err := protocol.WriteInt32(w, m.RebalanceTimeoutMs); err != nil {
			return err
		}
	}
	// Topology
	if version >= 0 && version <= 999 {
		// Epoch
		if version >= 0 && version <= 999 {
			if err := protocol.WriteInt32(w, m.Topology.Epoch); err != nil {
				return err
			}
		}
		// Subtopologies
		if version >= 0 && version <= 999 {
			if isFlexible {
				length := uint32(len(m.Topology.Subtopologies) + 1)
				if err := protocol.WriteVaruint32(w, length); err != nil {
					return err
				}
			} else {
				if err := protocol.WriteInt32(w, int32(len(m.Topology.Subtopologies))); err != nil {
					return err
				}
			}
			for i := range m.Topology.Subtopologies {
				// SubtopologyId
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactString(w, m.Topology.Subtopologies[i].SubtopologyId); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteString(w, m.Topology.Subtopologies[i].SubtopologyId); err != nil {
							return err
						}
					}
				}
				// SourceTopics
				if version >= 0 && version <= 999 {
					if isFlexible {
						length := uint32(len(m.Topology.Subtopologies[i].SourceTopics) + 1)
						if err := protocol.WriteVaruint32(w, length); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteInt32(w, int32(len(m.Topology.Subtopologies[i].SourceTopics))); err != nil {
							return err
						}
					}
					for i := range m.Topology.Subtopologies[i].SourceTopics {
						if isFlexible {
							if err := protocol.WriteCompactString(w, m.Topology.Subtopologies[i].SourceTopics[i]); err != nil {
								return err
							}
						} else {
							if err := protocol.WriteString(w, m.Topology.Subtopologies[i].SourceTopics[i]); err != nil {
								return err
							}
						}
						_ = i
					}
				}
				// SourceTopicRegex
				if version >= 0 && version <= 999 {
					if isFlexible {
						length := uint32(len(m.Topology.Subtopologies[i].SourceTopicRegex) + 1)
						if err := protocol.WriteVaruint32(w, length); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteInt32(w, int32(len(m.Topology.Subtopologies[i].SourceTopicRegex))); err != nil {
							return err
						}
					}
					for i := range m.Topology.Subtopologies[i].SourceTopicRegex {
						if isFlexible {
							if err := protocol.WriteCompactString(w, m.Topology.Subtopologies[i].SourceTopicRegex[i]); err != nil {
								return err
							}
						} else {
							if err := protocol.WriteString(w, m.Topology.Subtopologies[i].SourceTopicRegex[i]); err != nil {
								return err
							}
						}
						_ = i
					}
				}
				// StateChangelogTopics
				if version >= 0 && version <= 999 {
					if isFlexible {
						length := uint32(len(m.Topology.Subtopologies[i].StateChangelogTopics) + 1)
						if err := protocol.WriteVaruint32(w, length); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteInt32(w, int32(len(m.Topology.Subtopologies[i].StateChangelogTopics))); err != nil {
							return err
						}
					}
					for i := range m.Topology.Subtopologies[i].StateChangelogTopics {
						// Name
						if version >= 0 && version <= 999 {
							if isFlexible {
								if err := protocol.WriteCompactString(w, m.Topology.Subtopologies[i].StateChangelogTopics[i].Name); err != nil {
									return err
								}
							} else {
								if err := protocol.WriteString(w, m.Topology.Subtopologies[i].StateChangelogTopics[i].Name); err != nil {
									return err
								}
							}
						}
						// Partitions
						if version >= 0 && version <= 999 {
							if err := protocol.WriteInt32(w, m.Topology.Subtopologies[i].StateChangelogTopics[i].Partitions); err != nil {
								return err
							}
						}
						// ReplicationFactor
						if version >= 0 && version <= 999 {
							if err := protocol.WriteInt16(w, m.Topology.Subtopologies[i].StateChangelogTopics[i].ReplicationFactor); err != nil {
								return err
							}
						}
						// TopicConfigs
						if version >= 0 && version <= 999 {
							if isFlexible {
								length := uint32(len(m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs) + 1)
								if err := protocol.WriteVaruint32(w, length); err != nil {
									return err
								}
							} else {
								if err := protocol.WriteInt32(w, int32(len(m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs))); err != nil {
									return err
								}
							}
							for i := range m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs {
								// Key
								if version >= 0 && version <= 999 {
									if isFlexible {
										if err := protocol.WriteCompactString(w, m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Key); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteString(w, m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Key); err != nil {
											return err
										}
									}
								}
								// Value
								if version >= 0 && version <= 999 {
									if isFlexible {
										if err := protocol.WriteCompactString(w, m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Value); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteString(w, m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Value); err != nil {
											return err
										}
									}
								}
							}
						}
					}
				}
				// RepartitionSinkTopics
				if version >= 0 && version <= 999 {
					if isFlexible {
						length := uint32(len(m.Topology.Subtopologies[i].RepartitionSinkTopics) + 1)
						if err := protocol.WriteVaruint32(w, length); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteInt32(w, int32(len(m.Topology.Subtopologies[i].RepartitionSinkTopics))); err != nil {
							return err
						}
					}
					for i := range m.Topology.Subtopologies[i].RepartitionSinkTopics {
						if isFlexible {
							if err := protocol.WriteCompactString(w, m.Topology.Subtopologies[i].RepartitionSinkTopics[i]); err != nil {
								return err
							}
						} else {
							if err := protocol.WriteString(w, m.Topology.Subtopologies[i].RepartitionSinkTopics[i]); err != nil {
								return err
							}
						}
						_ = i
					}
				}
				// RepartitionSourceTopics
				if version >= 0 && version <= 999 {
					if isFlexible {
						length := uint32(len(m.Topology.Subtopologies[i].RepartitionSourceTopics) + 1)
						if err := protocol.WriteVaruint32(w, length); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteInt32(w, int32(len(m.Topology.Subtopologies[i].RepartitionSourceTopics))); err != nil {
							return err
						}
					}
					for i := range m.Topology.Subtopologies[i].RepartitionSourceTopics {
						// Name
						if version >= 0 && version <= 999 {
							if isFlexible {
								if err := protocol.WriteCompactString(w, m.Topology.Subtopologies[i].RepartitionSourceTopics[i].Name); err != nil {
									return err
								}
							} else {
								if err := protocol.WriteString(w, m.Topology.Subtopologies[i].RepartitionSourceTopics[i].Name); err != nil {
									return err
								}
							}
						}
						// Partitions
						if version >= 0 && version <= 999 {
							if err := protocol.WriteInt32(w, m.Topology.Subtopologies[i].RepartitionSourceTopics[i].Partitions); err != nil {
								return err
							}
						}
						// ReplicationFactor
						if version >= 0 && version <= 999 {
							if err := protocol.WriteInt16(w, m.Topology.Subtopologies[i].RepartitionSourceTopics[i].ReplicationFactor); err != nil {
								return err
							}
						}
						// TopicConfigs
						if version >= 0 && version <= 999 {
							if isFlexible {
								length := uint32(len(m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs) + 1)
								if err := protocol.WriteVaruint32(w, length); err != nil {
									return err
								}
							} else {
								if err := protocol.WriteInt32(w, int32(len(m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs))); err != nil {
									return err
								}
							}
							for i := range m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs {
								// Key
								if version >= 0 && version <= 999 {
									if isFlexible {
										if err := protocol.WriteCompactString(w, m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Key); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteString(w, m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Key); err != nil {
											return err
										}
									}
								}
								// Value
								if version >= 0 && version <= 999 {
									if isFlexible {
										if err := protocol.WriteCompactString(w, m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Value); err != nil {
											return err
										}
									} else {
										if err := protocol.WriteString(w, m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Value); err != nil {
											return err
										}
									}
								}
							}
						}
					}
				}
				// CopartitionGroups
				if version >= 0 && version <= 999 {
					if isFlexible {
						length := uint32(len(m.Topology.Subtopologies[i].CopartitionGroups) + 1)
						if err := protocol.WriteVaruint32(w, length); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteInt32(w, int32(len(m.Topology.Subtopologies[i].CopartitionGroups))); err != nil {
							return err
						}
					}
					for i := range m.Topology.Subtopologies[i].CopartitionGroups {
						// SourceTopics
						if version >= 0 && version <= 999 {
							if isFlexible {
								length := uint32(len(m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopics) + 1)
								if err := protocol.WriteVaruint32(w, length); err != nil {
									return err
								}
							} else {
								if err := protocol.WriteInt32(w, int32(len(m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopics))); err != nil {
									return err
								}
							}
							for i := range m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopics {
								if err := protocol.WriteInt16(w, m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopics[i]); err != nil {
									return err
								}
								_ = i
							}
						}
						// SourceTopicRegex
						if version >= 0 && version <= 999 {
							if isFlexible {
								length := uint32(len(m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopicRegex) + 1)
								if err := protocol.WriteVaruint32(w, length); err != nil {
									return err
								}
							} else {
								if err := protocol.WriteInt32(w, int32(len(m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopicRegex))); err != nil {
									return err
								}
							}
							for i := range m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopicRegex {
								if err := protocol.WriteInt16(w, m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopicRegex[i]); err != nil {
									return err
								}
								_ = i
							}
						}
						// RepartitionSourceTopics
						if version >= 0 && version <= 999 {
							if isFlexible {
								length := uint32(len(m.Topology.Subtopologies[i].CopartitionGroups[i].RepartitionSourceTopics) + 1)
								if err := protocol.WriteVaruint32(w, length); err != nil {
									return err
								}
							} else {
								if err := protocol.WriteInt32(w, int32(len(m.Topology.Subtopologies[i].CopartitionGroups[i].RepartitionSourceTopics))); err != nil {
									return err
								}
							}
							for i := range m.Topology.Subtopologies[i].CopartitionGroups[i].RepartitionSourceTopics {
								if err := protocol.WriteInt16(w, m.Topology.Subtopologies[i].CopartitionGroups[i].RepartitionSourceTopics[i]); err != nil {
									return err
								}
								_ = i
							}
						}
					}
				}
			}
		}
	}
	// ActiveTasks
	if version >= 0 && version <= 999 {
		if m.ActiveTasks == nil {
			if isFlexible {
				if err := protocol.WriteVaruint32(w, 0); err != nil {
					return err
				}
			} else {
				if err := protocol.WriteInt32(w, -1); err != nil {
					return err
				}
			}
		} else {
			if isFlexible {
				length := uint32(len(m.ActiveTasks) + 1)
				if err := protocol.WriteVaruint32(w, length); err != nil {
					return err
				}
			} else {
				if err := protocol.WriteInt32(w, int32(len(m.ActiveTasks))); err != nil {
					return err
				}
			}
			for i := range m.ActiveTasks {
				// SubtopologyId
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactString(w, m.ActiveTasks[i].SubtopologyId); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteString(w, m.ActiveTasks[i].SubtopologyId); err != nil {
							return err
						}
					}
				}
				// Partitions
				if version >= 0 && version <= 999 {
					if isFlexible {
						length := uint32(len(m.ActiveTasks[i].Partitions) + 1)
						if err := protocol.WriteVaruint32(w, length); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteInt32(w, int32(len(m.ActiveTasks[i].Partitions))); err != nil {
							return err
						}
					}
					for i := range m.ActiveTasks[i].Partitions {
						if err := protocol.WriteInt32(w, m.ActiveTasks[i].Partitions[i]); err != nil {
							return err
						}
						_ = i
					}
				}
			}
		}
	}
	// StandbyTasks
	if version >= 0 && version <= 999 {
		if m.StandbyTasks == nil {
			if isFlexible {
				if err := protocol.WriteVaruint32(w, 0); err != nil {
					return err
				}
			} else {
				if err := protocol.WriteInt32(w, -1); err != nil {
					return err
				}
			}
		} else {
			if isFlexible {
				length := uint32(len(m.StandbyTasks) + 1)
				if err := protocol.WriteVaruint32(w, length); err != nil {
					return err
				}
			} else {
				if err := protocol.WriteInt32(w, int32(len(m.StandbyTasks))); err != nil {
					return err
				}
			}
			for i := range m.StandbyTasks {
				// SubtopologyId
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactString(w, m.StandbyTasks[i].SubtopologyId); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteString(w, m.StandbyTasks[i].SubtopologyId); err != nil {
							return err
						}
					}
				}
				// Partitions
				if version >= 0 && version <= 999 {
					if isFlexible {
						length := uint32(len(m.StandbyTasks[i].Partitions) + 1)
						if err := protocol.WriteVaruint32(w, length); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteInt32(w, int32(len(m.StandbyTasks[i].Partitions))); err != nil {
							return err
						}
					}
					for i := range m.StandbyTasks[i].Partitions {
						if err := protocol.WriteInt32(w, m.StandbyTasks[i].Partitions[i]); err != nil {
							return err
						}
						_ = i
					}
				}
			}
		}
	}
	// WarmupTasks
	if version >= 0 && version <= 999 {
		if m.WarmupTasks == nil {
			if isFlexible {
				if err := protocol.WriteVaruint32(w, 0); err != nil {
					return err
				}
			} else {
				if err := protocol.WriteInt32(w, -1); err != nil {
					return err
				}
			}
		} else {
			if isFlexible {
				length := uint32(len(m.WarmupTasks) + 1)
				if err := protocol.WriteVaruint32(w, length); err != nil {
					return err
				}
			} else {
				if err := protocol.WriteInt32(w, int32(len(m.WarmupTasks))); err != nil {
					return err
				}
			}
			for i := range m.WarmupTasks {
				// SubtopologyId
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactString(w, m.WarmupTasks[i].SubtopologyId); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteString(w, m.WarmupTasks[i].SubtopologyId); err != nil {
							return err
						}
					}
				}
				// Partitions
				if version >= 0 && version <= 999 {
					if isFlexible {
						length := uint32(len(m.WarmupTasks[i].Partitions) + 1)
						if err := protocol.WriteVaruint32(w, length); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteInt32(w, int32(len(m.WarmupTasks[i].Partitions))); err != nil {
							return err
						}
					}
					for i := range m.WarmupTasks[i].Partitions {
						if err := protocol.WriteInt32(w, m.WarmupTasks[i].Partitions[i]); err != nil {
							return err
						}
						_ = i
					}
				}
			}
		}
	}
	// ProcessId
	if version >= 0 && version <= 999 {
		if isFlexible {
			if err := protocol.WriteCompactNullableString(w, m.ProcessId); err != nil {
				return err
			}
		} else {
			if err := protocol.WriteNullableString(w, m.ProcessId); err != nil {
				return err
			}
		}
	}
	// UserEndpoint
	if version >= 0 && version <= 999 {
	}
	// ClientTags
	if version >= 0 && version <= 999 {
		if m.ClientTags == nil {
			if isFlexible {
				if err := protocol.WriteVaruint32(w, 0); err != nil {
					return err
				}
			} else {
				if err := protocol.WriteInt32(w, -1); err != nil {
					return err
				}
			}
		} else {
			if isFlexible {
				length := uint32(len(m.ClientTags) + 1)
				if err := protocol.WriteVaruint32(w, length); err != nil {
					return err
				}
			} else {
				if err := protocol.WriteInt32(w, int32(len(m.ClientTags))); err != nil {
					return err
				}
			}
			for i := range m.ClientTags {
				// Key
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactString(w, m.ClientTags[i].Key); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteString(w, m.ClientTags[i].Key); err != nil {
							return err
						}
					}
				}
				// Value
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactString(w, m.ClientTags[i].Value); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteString(w, m.ClientTags[i].Value); err != nil {
							return err
						}
					}
				}
			}
		}
	}
	// TaskOffsets
	if version >= 0 && version <= 999 {
		if m.TaskOffsets == nil {
			if isFlexible {
				if err := protocol.WriteVaruint32(w, 0); err != nil {
					return err
				}
			} else {
				if err := protocol.WriteInt32(w, -1); err != nil {
					return err
				}
			}
		} else {
			if isFlexible {
				length := uint32(len(m.TaskOffsets) + 1)
				if err := protocol.WriteVaruint32(w, length); err != nil {
					return err
				}
			} else {
				if err := protocol.WriteInt32(w, int32(len(m.TaskOffsets))); err != nil {
					return err
				}
			}
			for i := range m.TaskOffsets {
				// SubtopologyId
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactString(w, m.TaskOffsets[i].SubtopologyId); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteString(w, m.TaskOffsets[i].SubtopologyId); err != nil {
							return err
						}
					}
				}
				// Partition
				if version >= 0 && version <= 999 {
					if err := protocol.WriteInt32(w, m.TaskOffsets[i].Partition); err != nil {
						return err
					}
				}
				// Offset
				if version >= 0 && version <= 999 {
					if err := protocol.WriteInt64(w, m.TaskOffsets[i].Offset); err != nil {
						return err
					}
				}
			}
		}
	}
	// TaskEndOffsets
	if version >= 0 && version <= 999 {
		if m.TaskEndOffsets == nil {
			if isFlexible {
				if err := protocol.WriteVaruint32(w, 0); err != nil {
					return err
				}
			} else {
				if err := protocol.WriteInt32(w, -1); err != nil {
					return err
				}
			}
		} else {
			if isFlexible {
				length := uint32(len(m.TaskEndOffsets) + 1)
				if err := protocol.WriteVaruint32(w, length); err != nil {
					return err
				}
			} else {
				if err := protocol.WriteInt32(w, int32(len(m.TaskEndOffsets))); err != nil {
					return err
				}
			}
			for i := range m.TaskEndOffsets {
				// SubtopologyId
				if version >= 0 && version <= 999 {
					if isFlexible {
						if err := protocol.WriteCompactString(w, m.TaskEndOffsets[i].SubtopologyId); err != nil {
							return err
						}
					} else {
						if err := protocol.WriteString(w, m.TaskEndOffsets[i].SubtopologyId); err != nil {
							return err
						}
					}
				}
				// Partition
				if version >= 0 && version <= 999 {
					if err := protocol.WriteInt32(w, m.TaskEndOffsets[i].Partition); err != nil {
						return err
					}
				}
				// Offset
				if version >= 0 && version <= 999 {
					if err := protocol.WriteInt64(w, m.TaskEndOffsets[i].Offset); err != nil {
						return err
					}
				}
			}
		}
	}
	// ShutdownApplication
	if version >= 0 && version <= 999 {
		if err := protocol.WriteBool(w, m.ShutdownApplication); err != nil {
			return err
		}
	}
	// Write tagged fields if flexible
	if isFlexible {
		if err := m.writeTaggedFields(w, version); err != nil {
			return err
		}
	}
	return nil
}

// Read reads a StreamsGroupHeartbeatRequest from an io.Reader for the given version.
func (m *StreamsGroupHeartbeatRequest) Read(r io.Reader, version int16) error {
	if version < 0 || version > 0 {
		return errors.New("unsupported version")
	}

	isFlexible := false
	if version >= 0 {
		isFlexible = true
	}

	// GroupId
	if version >= 0 && version <= 999 {
		if isFlexible {
			val, err := protocol.ReadCompactString(r)
			if err != nil {
				return err
			}
			m.GroupId = val
		} else {
			val, err := protocol.ReadString(r)
			if err != nil {
				return err
			}
			m.GroupId = val
		}
	}
	// MemberId
	if version >= 0 && version <= 999 {
		if isFlexible {
			val, err := protocol.ReadCompactString(r)
			if err != nil {
				return err
			}
			m.MemberId = val
		} else {
			val, err := protocol.ReadString(r)
			if err != nil {
				return err
			}
			m.MemberId = val
		}
	}
	// MemberEpoch
	if version >= 0 && version <= 999 {
		val, err := protocol.ReadInt32(r)
		if err != nil {
			return err
		}
		m.MemberEpoch = val
	}
	// EndpointInformationEpoch
	if version >= 0 && version <= 999 {
		val, err := protocol.ReadInt32(r)
		if err != nil {
			return err
		}
		m.EndpointInformationEpoch = val
	}
	// InstanceId
	if version >= 0 && version <= 999 {
		if isFlexible {
			val, err := protocol.ReadCompactNullableString(r)
			if err != nil {
				return err
			}
			m.InstanceId = val
		} else {
			val, err := protocol.ReadNullableString(r)
			if err != nil {
				return err
			}
			m.InstanceId = val
		}
	}
	// RackId
	if version >= 0 && version <= 999 {
		if isFlexible {
			val, err := protocol.ReadCompactNullableString(r)
			if err != nil {
				return err
			}
			m.RackId = val
		} else {
			val, err := protocol.ReadNullableString(r)
			if err != nil {
				return err
			}
			m.RackId = val
		}
	}
	// RebalanceTimeoutMs
	if version >= 0 && version <= 999 {
		val, err := protocol.ReadInt32(r)
		if err != nil {
			return err
		}
		m.RebalanceTimeoutMs = val
	}
	// Topology
	if version >= 0 && version <= 999 {
		// Epoch
		if version >= 0 && version <= 999 {
			val, err := protocol.ReadInt32(r)
			if err != nil {
				return err
			}
			m.Topology.Epoch = val
		}
		// Subtopologies
		if version >= 0 && version <= 999 {
			var length int32
			if isFlexible {
				var lengthUint uint32
				lengthUint, err := protocol.ReadVaruint32(r)
				if err != nil {
					return err
				}
				if lengthUint < 1 {
					return errors.New("invalid compact array length")
				}
				length = int32(lengthUint - 1)
				m.Topology.Subtopologies = make([]StreamsGroupHeartbeatRequestSubtopology, length)
				for i := int32(0); i < length; i++ {
					// SubtopologyId
					if version >= 0 && version <= 999 {
						if isFlexible {
							val, err := protocol.ReadCompactString(r)
							if err != nil {
								return err
							}
							m.Topology.Subtopologies[i].SubtopologyId = val
						} else {
							val, err := protocol.ReadString(r)
							if err != nil {
								return err
							}
							m.Topology.Subtopologies[i].SubtopologyId = val
						}
					}
					// SourceTopics
					if version >= 0 && version <= 999 {
						var length int32
						if isFlexible {
							var lengthUint uint32
							lengthUint, err := protocol.ReadVaruint32(r)
							if err != nil {
								return err
							}
							if lengthUint < 1 {
								return errors.New("invalid compact array length")
							}
							length = int32(lengthUint - 1)
							m.Topology.Subtopologies[i].SourceTopics = make([]string, length)
							for i := int32(0); i < length; i++ {
								if isFlexible {
									val, err := protocol.ReadCompactString(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].SourceTopics[i] = val
								} else {
									val, err := protocol.ReadString(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].SourceTopics[i] = val
								}
							}
						} else {
							var err error
							length, err = protocol.ReadInt32(r)
							if err != nil {
								return err
							}
							m.Topology.Subtopologies[i].SourceTopics = make([]string, length)
							for i := int32(0); i < length; i++ {
								if isFlexible {
									val, err := protocol.ReadCompactString(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].SourceTopics[i] = val
								} else {
									val, err := protocol.ReadString(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].SourceTopics[i] = val
								}
							}
						}
					}
					// SourceTopicRegex
					if version >= 0 && version <= 999 {
						var length int32
						if isFlexible {
							var lengthUint uint32
							lengthUint, err := protocol.ReadVaruint32(r)
							if err != nil {
								return err
							}
							if lengthUint < 1 {
								return errors.New("invalid compact array length")
							}
							length = int32(lengthUint - 1)
							m.Topology.Subtopologies[i].SourceTopicRegex = make([]string, length)
							for i := int32(0); i < length; i++ {
								if isFlexible {
									val, err := protocol.ReadCompactString(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].SourceTopicRegex[i] = val
								} else {
									val, err := protocol.ReadString(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].SourceTopicRegex[i] = val
								}
							}
						} else {
							var err error
							length, err = protocol.ReadInt32(r)
							if err != nil {
								return err
							}
							m.Topology.Subtopologies[i].SourceTopicRegex = make([]string, length)
							for i := int32(0); i < length; i++ {
								if isFlexible {
									val, err := protocol.ReadCompactString(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].SourceTopicRegex[i] = val
								} else {
									val, err := protocol.ReadString(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].SourceTopicRegex[i] = val
								}
							}
						}
					}
					// StateChangelogTopics
					if version >= 0 && version <= 999 {
						var length int32
						if isFlexible {
							var lengthUint uint32
							lengthUint, err := protocol.ReadVaruint32(r)
							if err != nil {
								return err
							}
							if lengthUint < 1 {
								return errors.New("invalid compact array length")
							}
							length = int32(lengthUint - 1)
							m.Topology.Subtopologies[i].StateChangelogTopics = make([]TopicInfo, length)
							for i := int32(0); i < length; i++ {
								// Name
								if version >= 0 && version <= 999 {
									if isFlexible {
										val, err := protocol.ReadCompactString(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].StateChangelogTopics[i].Name = val
									} else {
										val, err := protocol.ReadString(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].StateChangelogTopics[i].Name = val
									}
								}
								// Partitions
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt32(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].StateChangelogTopics[i].Partitions = val
								}
								// ReplicationFactor
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt16(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].StateChangelogTopics[i].ReplicationFactor = val
								}
								// TopicConfigs
								if version >= 0 && version <= 999 {
									var length int32
									if isFlexible {
										var lengthUint uint32
										lengthUint, err := protocol.ReadVaruint32(r)
										if err != nil {
											return err
										}
										if lengthUint < 1 {
											return errors.New("invalid compact array length")
										}
										length = int32(lengthUint - 1)
										m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs = make([]KeyValue, length)
										for i := int32(0); i < length; i++ {
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Value = val
												}
											}
										}
									} else {
										var err error
										length, err = protocol.ReadInt32(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs = make([]KeyValue, length)
										for i := int32(0); i < length; i++ {
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Value = val
												}
											}
										}
									}
								}
							}
						} else {
							var err error
							length, err = protocol.ReadInt32(r)
							if err != nil {
								return err
							}
							m.Topology.Subtopologies[i].StateChangelogTopics = make([]TopicInfo, length)
							for i := int32(0); i < length; i++ {
								// Name
								if version >= 0 && version <= 999 {
									if isFlexible {
										val, err := protocol.ReadCompactString(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].StateChangelogTopics[i].Name = val
									} else {
										val, err := protocol.ReadString(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].StateChangelogTopics[i].Name = val
									}
								}
								// Partitions
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt32(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].StateChangelogTopics[i].Partitions = val
								}
								// ReplicationFactor
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt16(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].StateChangelogTopics[i].ReplicationFactor = val
								}
								// TopicConfigs
								if version >= 0 && version <= 999 {
									var length int32
									if isFlexible {
										var lengthUint uint32
										lengthUint, err := protocol.ReadVaruint32(r)
										if err != nil {
											return err
										}
										if lengthUint < 1 {
											return errors.New("invalid compact array length")
										}
										length = int32(lengthUint - 1)
										m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs = make([]KeyValue, length)
										for i := int32(0); i < length; i++ {
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Value = val
												}
											}
										}
									} else {
										var err error
										length, err = protocol.ReadInt32(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs = make([]KeyValue, length)
										for i := int32(0); i < length; i++ {
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Value = val
												}
											}
										}
									}
								}
							}
						}
					}
					// RepartitionSinkTopics
					if version >= 0 && version <= 999 {
						var length int32
						if isFlexible {
							var lengthUint uint32
							lengthUint, err := protocol.ReadVaruint32(r)
							if err != nil {
								return err
							}
							if lengthUint < 1 {
								return errors.New("invalid compact array length")
							}
							length = int32(lengthUint - 1)
							m.Topology.Subtopologies[i].RepartitionSinkTopics = make([]string, length)
							for i := int32(0); i < length; i++ {
								if isFlexible {
									val, err := protocol.ReadCompactString(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].RepartitionSinkTopics[i] = val
								} else {
									val, err := protocol.ReadString(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].RepartitionSinkTopics[i] = val
								}
							}
						} else {
							var err error
							length, err = protocol.ReadInt32(r)
							if err != nil {
								return err
							}
							m.Topology.Subtopologies[i].RepartitionSinkTopics = make([]string, length)
							for i := int32(0); i < length; i++ {
								if isFlexible {
									val, err := protocol.ReadCompactString(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].RepartitionSinkTopics[i] = val
								} else {
									val, err := protocol.ReadString(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].RepartitionSinkTopics[i] = val
								}
							}
						}
					}
					// RepartitionSourceTopics
					if version >= 0 && version <= 999 {
						var length int32
						if isFlexible {
							var lengthUint uint32
							lengthUint, err := protocol.ReadVaruint32(r)
							if err != nil {
								return err
							}
							if lengthUint < 1 {
								return errors.New("invalid compact array length")
							}
							length = int32(lengthUint - 1)
							m.Topology.Subtopologies[i].RepartitionSourceTopics = make([]TopicInfo, length)
							for i := int32(0); i < length; i++ {
								// Name
								if version >= 0 && version <= 999 {
									if isFlexible {
										val, err := protocol.ReadCompactString(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].RepartitionSourceTopics[i].Name = val
									} else {
										val, err := protocol.ReadString(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].RepartitionSourceTopics[i].Name = val
									}
								}
								// Partitions
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt32(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].RepartitionSourceTopics[i].Partitions = val
								}
								// ReplicationFactor
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt16(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].RepartitionSourceTopics[i].ReplicationFactor = val
								}
								// TopicConfigs
								if version >= 0 && version <= 999 {
									var length int32
									if isFlexible {
										var lengthUint uint32
										lengthUint, err := protocol.ReadVaruint32(r)
										if err != nil {
											return err
										}
										if lengthUint < 1 {
											return errors.New("invalid compact array length")
										}
										length = int32(lengthUint - 1)
										m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs = make([]KeyValue, length)
										for i := int32(0); i < length; i++ {
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Value = val
												}
											}
										}
									} else {
										var err error
										length, err = protocol.ReadInt32(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs = make([]KeyValue, length)
										for i := int32(0); i < length; i++ {
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Value = val
												}
											}
										}
									}
								}
							}
						} else {
							var err error
							length, err = protocol.ReadInt32(r)
							if err != nil {
								return err
							}
							m.Topology.Subtopologies[i].RepartitionSourceTopics = make([]TopicInfo, length)
							for i := int32(0); i < length; i++ {
								// Name
								if version >= 0 && version <= 999 {
									if isFlexible {
										val, err := protocol.ReadCompactString(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].RepartitionSourceTopics[i].Name = val
									} else {
										val, err := protocol.ReadString(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].RepartitionSourceTopics[i].Name = val
									}
								}
								// Partitions
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt32(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].RepartitionSourceTopics[i].Partitions = val
								}
								// ReplicationFactor
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt16(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].RepartitionSourceTopics[i].ReplicationFactor = val
								}
								// TopicConfigs
								if version >= 0 && version <= 999 {
									var length int32
									if isFlexible {
										var lengthUint uint32
										lengthUint, err := protocol.ReadVaruint32(r)
										if err != nil {
											return err
										}
										if lengthUint < 1 {
											return errors.New("invalid compact array length")
										}
										length = int32(lengthUint - 1)
										m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs = make([]KeyValue, length)
										for i := int32(0); i < length; i++ {
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Value = val
												}
											}
										}
									} else {
										var err error
										length, err = protocol.ReadInt32(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs = make([]KeyValue, length)
										for i := int32(0); i < length; i++ {
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Value = val
												}
											}
										}
									}
								}
							}
						}
					}
					// CopartitionGroups
					if version >= 0 && version <= 999 {
						var length int32
						if isFlexible {
							var lengthUint uint32
							lengthUint, err := protocol.ReadVaruint32(r)
							if err != nil {
								return err
							}
							if lengthUint < 1 {
								return errors.New("invalid compact array length")
							}
							length = int32(lengthUint - 1)
							m.Topology.Subtopologies[i].CopartitionGroups = make([]StreamsGroupHeartbeatRequestCopartitionGroup, length)
							for i := int32(0); i < length; i++ {
								// SourceTopics
								if version >= 0 && version <= 999 {
									var length int32
									if isFlexible {
										var lengthUint uint32
										lengthUint, err := protocol.ReadVaruint32(r)
										if err != nil {
											return err
										}
										if lengthUint < 1 {
											return errors.New("invalid compact array length")
										}
										length = int32(lengthUint - 1)
										m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopics = make([]int16, length)
										for i := int32(0); i < length; i++ {
											val, err := protocol.ReadInt16(r)
											if err != nil {
												return err
											}
											m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopics[i] = val
										}
									} else {
										var err error
										length, err = protocol.ReadInt32(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopics = make([]int16, length)
										for i := int32(0); i < length; i++ {
											val, err := protocol.ReadInt16(r)
											if err != nil {
												return err
											}
											m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopics[i] = val
										}
									}
								}
								// SourceTopicRegex
								if version >= 0 && version <= 999 {
									var length int32
									if isFlexible {
										var lengthUint uint32
										lengthUint, err := protocol.ReadVaruint32(r)
										if err != nil {
											return err
										}
										if lengthUint < 1 {
											return errors.New("invalid compact array length")
										}
										length = int32(lengthUint - 1)
										m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopicRegex = make([]int16, length)
										for i := int32(0); i < length; i++ {
											val, err := protocol.ReadInt16(r)
											if err != nil {
												return err
											}
											m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopicRegex[i] = val
										}
									} else {
										var err error
										length, err = protocol.ReadInt32(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopicRegex = make([]int16, length)
										for i := int32(0); i < length; i++ {
											val, err := protocol.ReadInt16(r)
											if err != nil {
												return err
											}
											m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopicRegex[i] = val
										}
									}
								}
								// RepartitionSourceTopics
								if version >= 0 && version <= 999 {
									var length int32
									if isFlexible {
										var lengthUint uint32
										lengthUint, err := protocol.ReadVaruint32(r)
										if err != nil {
											return err
										}
										if lengthUint < 1 {
											return errors.New("invalid compact array length")
										}
										length = int32(lengthUint - 1)
										m.Topology.Subtopologies[i].CopartitionGroups[i].RepartitionSourceTopics = make([]int16, length)
										for i := int32(0); i < length; i++ {
											val, err := protocol.ReadInt16(r)
											if err != nil {
												return err
											}
											m.Topology.Subtopologies[i].CopartitionGroups[i].RepartitionSourceTopics[i] = val
										}
									} else {
										var err error
										length, err = protocol.ReadInt32(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].CopartitionGroups[i].RepartitionSourceTopics = make([]int16, length)
										for i := int32(0); i < length; i++ {
											val, err := protocol.ReadInt16(r)
											if err != nil {
												return err
											}
											m.Topology.Subtopologies[i].CopartitionGroups[i].RepartitionSourceTopics[i] = val
										}
									}
								}
							}
						} else {
							var err error
							length, err = protocol.ReadInt32(r)
							if err != nil {
								return err
							}
							m.Topology.Subtopologies[i].CopartitionGroups = make([]StreamsGroupHeartbeatRequestCopartitionGroup, length)
							for i := int32(0); i < length; i++ {
								// SourceTopics
								if version >= 0 && version <= 999 {
									var length int32
									if isFlexible {
										var lengthUint uint32
										lengthUint, err := protocol.ReadVaruint32(r)
										if err != nil {
											return err
										}
										if lengthUint < 1 {
											return errors.New("invalid compact array length")
										}
										length = int32(lengthUint - 1)
										m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopics = make([]int16, length)
										for i := int32(0); i < length; i++ {
											val, err := protocol.ReadInt16(r)
											if err != nil {
												return err
											}
											m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopics[i] = val
										}
									} else {
										var err error
										length, err = protocol.ReadInt32(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopics = make([]int16, length)
										for i := int32(0); i < length; i++ {
											val, err := protocol.ReadInt16(r)
											if err != nil {
												return err
											}
											m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopics[i] = val
										}
									}
								}
								// SourceTopicRegex
								if version >= 0 && version <= 999 {
									var length int32
									if isFlexible {
										var lengthUint uint32
										lengthUint, err := protocol.ReadVaruint32(r)
										if err != nil {
											return err
										}
										if lengthUint < 1 {
											return errors.New("invalid compact array length")
										}
										length = int32(lengthUint - 1)
										m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopicRegex = make([]int16, length)
										for i := int32(0); i < length; i++ {
											val, err := protocol.ReadInt16(r)
											if err != nil {
												return err
											}
											m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopicRegex[i] = val
										}
									} else {
										var err error
										length, err = protocol.ReadInt32(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopicRegex = make([]int16, length)
										for i := int32(0); i < length; i++ {
											val, err := protocol.ReadInt16(r)
											if err != nil {
												return err
											}
											m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopicRegex[i] = val
										}
									}
								}
								// RepartitionSourceTopics
								if version >= 0 && version <= 999 {
									var length int32
									if isFlexible {
										var lengthUint uint32
										lengthUint, err := protocol.ReadVaruint32(r)
										if err != nil {
											return err
										}
										if lengthUint < 1 {
											return errors.New("invalid compact array length")
										}
										length = int32(lengthUint - 1)
										m.Topology.Subtopologies[i].CopartitionGroups[i].RepartitionSourceTopics = make([]int16, length)
										for i := int32(0); i < length; i++ {
											val, err := protocol.ReadInt16(r)
											if err != nil {
												return err
											}
											m.Topology.Subtopologies[i].CopartitionGroups[i].RepartitionSourceTopics[i] = val
										}
									} else {
										var err error
										length, err = protocol.ReadInt32(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].CopartitionGroups[i].RepartitionSourceTopics = make([]int16, length)
										for i := int32(0); i < length; i++ {
											val, err := protocol.ReadInt16(r)
											if err != nil {
												return err
											}
											m.Topology.Subtopologies[i].CopartitionGroups[i].RepartitionSourceTopics[i] = val
										}
									}
								}
							}
						}
					}
				}
			} else {
				var err error
				length, err = protocol.ReadInt32(r)
				if err != nil {
					return err
				}
				m.Topology.Subtopologies = make([]StreamsGroupHeartbeatRequestSubtopology, length)
				for i := int32(0); i < length; i++ {
					// SubtopologyId
					if version >= 0 && version <= 999 {
						if isFlexible {
							val, err := protocol.ReadCompactString(r)
							if err != nil {
								return err
							}
							m.Topology.Subtopologies[i].SubtopologyId = val
						} else {
							val, err := protocol.ReadString(r)
							if err != nil {
								return err
							}
							m.Topology.Subtopologies[i].SubtopologyId = val
						}
					}
					// SourceTopics
					if version >= 0 && version <= 999 {
						var length int32
						if isFlexible {
							var lengthUint uint32
							lengthUint, err := protocol.ReadVaruint32(r)
							if err != nil {
								return err
							}
							if lengthUint < 1 {
								return errors.New("invalid compact array length")
							}
							length = int32(lengthUint - 1)
							m.Topology.Subtopologies[i].SourceTopics = make([]string, length)
							for i := int32(0); i < length; i++ {
								if isFlexible {
									val, err := protocol.ReadCompactString(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].SourceTopics[i] = val
								} else {
									val, err := protocol.ReadString(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].SourceTopics[i] = val
								}
							}
						} else {
							var err error
							length, err = protocol.ReadInt32(r)
							if err != nil {
								return err
							}
							m.Topology.Subtopologies[i].SourceTopics = make([]string, length)
							for i := int32(0); i < length; i++ {
								if isFlexible {
									val, err := protocol.ReadCompactString(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].SourceTopics[i] = val
								} else {
									val, err := protocol.ReadString(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].SourceTopics[i] = val
								}
							}
						}
					}
					// SourceTopicRegex
					if version >= 0 && version <= 999 {
						var length int32
						if isFlexible {
							var lengthUint uint32
							lengthUint, err := protocol.ReadVaruint32(r)
							if err != nil {
								return err
							}
							if lengthUint < 1 {
								return errors.New("invalid compact array length")
							}
							length = int32(lengthUint - 1)
							m.Topology.Subtopologies[i].SourceTopicRegex = make([]string, length)
							for i := int32(0); i < length; i++ {
								if isFlexible {
									val, err := protocol.ReadCompactString(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].SourceTopicRegex[i] = val
								} else {
									val, err := protocol.ReadString(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].SourceTopicRegex[i] = val
								}
							}
						} else {
							var err error
							length, err = protocol.ReadInt32(r)
							if err != nil {
								return err
							}
							m.Topology.Subtopologies[i].SourceTopicRegex = make([]string, length)
							for i := int32(0); i < length; i++ {
								if isFlexible {
									val, err := protocol.ReadCompactString(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].SourceTopicRegex[i] = val
								} else {
									val, err := protocol.ReadString(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].SourceTopicRegex[i] = val
								}
							}
						}
					}
					// StateChangelogTopics
					if version >= 0 && version <= 999 {
						var length int32
						if isFlexible {
							var lengthUint uint32
							lengthUint, err := protocol.ReadVaruint32(r)
							if err != nil {
								return err
							}
							if lengthUint < 1 {
								return errors.New("invalid compact array length")
							}
							length = int32(lengthUint - 1)
							m.Topology.Subtopologies[i].StateChangelogTopics = make([]TopicInfo, length)
							for i := int32(0); i < length; i++ {
								// Name
								if version >= 0 && version <= 999 {
									if isFlexible {
										val, err := protocol.ReadCompactString(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].StateChangelogTopics[i].Name = val
									} else {
										val, err := protocol.ReadString(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].StateChangelogTopics[i].Name = val
									}
								}
								// Partitions
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt32(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].StateChangelogTopics[i].Partitions = val
								}
								// ReplicationFactor
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt16(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].StateChangelogTopics[i].ReplicationFactor = val
								}
								// TopicConfigs
								if version >= 0 && version <= 999 {
									var length int32
									if isFlexible {
										var lengthUint uint32
										lengthUint, err := protocol.ReadVaruint32(r)
										if err != nil {
											return err
										}
										if lengthUint < 1 {
											return errors.New("invalid compact array length")
										}
										length = int32(lengthUint - 1)
										m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs = make([]KeyValue, length)
										for i := int32(0); i < length; i++ {
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Value = val
												}
											}
										}
									} else {
										var err error
										length, err = protocol.ReadInt32(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs = make([]KeyValue, length)
										for i := int32(0); i < length; i++ {
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Value = val
												}
											}
										}
									}
								}
							}
						} else {
							var err error
							length, err = protocol.ReadInt32(r)
							if err != nil {
								return err
							}
							m.Topology.Subtopologies[i].StateChangelogTopics = make([]TopicInfo, length)
							for i := int32(0); i < length; i++ {
								// Name
								if version >= 0 && version <= 999 {
									if isFlexible {
										val, err := protocol.ReadCompactString(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].StateChangelogTopics[i].Name = val
									} else {
										val, err := protocol.ReadString(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].StateChangelogTopics[i].Name = val
									}
								}
								// Partitions
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt32(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].StateChangelogTopics[i].Partitions = val
								}
								// ReplicationFactor
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt16(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].StateChangelogTopics[i].ReplicationFactor = val
								}
								// TopicConfigs
								if version >= 0 && version <= 999 {
									var length int32
									if isFlexible {
										var lengthUint uint32
										lengthUint, err := protocol.ReadVaruint32(r)
										if err != nil {
											return err
										}
										if lengthUint < 1 {
											return errors.New("invalid compact array length")
										}
										length = int32(lengthUint - 1)
										m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs = make([]KeyValue, length)
										for i := int32(0); i < length; i++ {
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Value = val
												}
											}
										}
									} else {
										var err error
										length, err = protocol.ReadInt32(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs = make([]KeyValue, length)
										for i := int32(0); i < length; i++ {
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].StateChangelogTopics[i].TopicConfigs[i].Value = val
												}
											}
										}
									}
								}
							}
						}
					}
					// RepartitionSinkTopics
					if version >= 0 && version <= 999 {
						var length int32
						if isFlexible {
							var lengthUint uint32
							lengthUint, err := protocol.ReadVaruint32(r)
							if err != nil {
								return err
							}
							if lengthUint < 1 {
								return errors.New("invalid compact array length")
							}
							length = int32(lengthUint - 1)
							m.Topology.Subtopologies[i].RepartitionSinkTopics = make([]string, length)
							for i := int32(0); i < length; i++ {
								if isFlexible {
									val, err := protocol.ReadCompactString(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].RepartitionSinkTopics[i] = val
								} else {
									val, err := protocol.ReadString(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].RepartitionSinkTopics[i] = val
								}
							}
						} else {
							var err error
							length, err = protocol.ReadInt32(r)
							if err != nil {
								return err
							}
							m.Topology.Subtopologies[i].RepartitionSinkTopics = make([]string, length)
							for i := int32(0); i < length; i++ {
								if isFlexible {
									val, err := protocol.ReadCompactString(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].RepartitionSinkTopics[i] = val
								} else {
									val, err := protocol.ReadString(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].RepartitionSinkTopics[i] = val
								}
							}
						}
					}
					// RepartitionSourceTopics
					if version >= 0 && version <= 999 {
						var length int32
						if isFlexible {
							var lengthUint uint32
							lengthUint, err := protocol.ReadVaruint32(r)
							if err != nil {
								return err
							}
							if lengthUint < 1 {
								return errors.New("invalid compact array length")
							}
							length = int32(lengthUint - 1)
							m.Topology.Subtopologies[i].RepartitionSourceTopics = make([]TopicInfo, length)
							for i := int32(0); i < length; i++ {
								// Name
								if version >= 0 && version <= 999 {
									if isFlexible {
										val, err := protocol.ReadCompactString(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].RepartitionSourceTopics[i].Name = val
									} else {
										val, err := protocol.ReadString(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].RepartitionSourceTopics[i].Name = val
									}
								}
								// Partitions
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt32(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].RepartitionSourceTopics[i].Partitions = val
								}
								// ReplicationFactor
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt16(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].RepartitionSourceTopics[i].ReplicationFactor = val
								}
								// TopicConfigs
								if version >= 0 && version <= 999 {
									var length int32
									if isFlexible {
										var lengthUint uint32
										lengthUint, err := protocol.ReadVaruint32(r)
										if err != nil {
											return err
										}
										if lengthUint < 1 {
											return errors.New("invalid compact array length")
										}
										length = int32(lengthUint - 1)
										m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs = make([]KeyValue, length)
										for i := int32(0); i < length; i++ {
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Value = val
												}
											}
										}
									} else {
										var err error
										length, err = protocol.ReadInt32(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs = make([]KeyValue, length)
										for i := int32(0); i < length; i++ {
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Value = val
												}
											}
										}
									}
								}
							}
						} else {
							var err error
							length, err = protocol.ReadInt32(r)
							if err != nil {
								return err
							}
							m.Topology.Subtopologies[i].RepartitionSourceTopics = make([]TopicInfo, length)
							for i := int32(0); i < length; i++ {
								// Name
								if version >= 0 && version <= 999 {
									if isFlexible {
										val, err := protocol.ReadCompactString(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].RepartitionSourceTopics[i].Name = val
									} else {
										val, err := protocol.ReadString(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].RepartitionSourceTopics[i].Name = val
									}
								}
								// Partitions
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt32(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].RepartitionSourceTopics[i].Partitions = val
								}
								// ReplicationFactor
								if version >= 0 && version <= 999 {
									val, err := protocol.ReadInt16(r)
									if err != nil {
										return err
									}
									m.Topology.Subtopologies[i].RepartitionSourceTopics[i].ReplicationFactor = val
								}
								// TopicConfigs
								if version >= 0 && version <= 999 {
									var length int32
									if isFlexible {
										var lengthUint uint32
										lengthUint, err := protocol.ReadVaruint32(r)
										if err != nil {
											return err
										}
										if lengthUint < 1 {
											return errors.New("invalid compact array length")
										}
										length = int32(lengthUint - 1)
										m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs = make([]KeyValue, length)
										for i := int32(0); i < length; i++ {
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Value = val
												}
											}
										}
									} else {
										var err error
										length, err = protocol.ReadInt32(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs = make([]KeyValue, length)
										for i := int32(0); i < length; i++ {
											// Key
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Key = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Key = val
												}
											}
											// Value
											if version >= 0 && version <= 999 {
												if isFlexible {
													val, err := protocol.ReadCompactString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Value = val
												} else {
													val, err := protocol.ReadString(r)
													if err != nil {
														return err
													}
													m.Topology.Subtopologies[i].RepartitionSourceTopics[i].TopicConfigs[i].Value = val
												}
											}
										}
									}
								}
							}
						}
					}
					// CopartitionGroups
					if version >= 0 && version <= 999 {
						var length int32
						if isFlexible {
							var lengthUint uint32
							lengthUint, err := protocol.ReadVaruint32(r)
							if err != nil {
								return err
							}
							if lengthUint < 1 {
								return errors.New("invalid compact array length")
							}
							length = int32(lengthUint - 1)
							m.Topology.Subtopologies[i].CopartitionGroups = make([]StreamsGroupHeartbeatRequestCopartitionGroup, length)
							for i := int32(0); i < length; i++ {
								// SourceTopics
								if version >= 0 && version <= 999 {
									var length int32
									if isFlexible {
										var lengthUint uint32
										lengthUint, err := protocol.ReadVaruint32(r)
										if err != nil {
											return err
										}
										if lengthUint < 1 {
											return errors.New("invalid compact array length")
										}
										length = int32(lengthUint - 1)
										m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopics = make([]int16, length)
										for i := int32(0); i < length; i++ {
											val, err := protocol.ReadInt16(r)
											if err != nil {
												return err
											}
											m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopics[i] = val
										}
									} else {
										var err error
										length, err = protocol.ReadInt32(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopics = make([]int16, length)
										for i := int32(0); i < length; i++ {
											val, err := protocol.ReadInt16(r)
											if err != nil {
												return err
											}
											m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopics[i] = val
										}
									}
								}
								// SourceTopicRegex
								if version >= 0 && version <= 999 {
									var length int32
									if isFlexible {
										var lengthUint uint32
										lengthUint, err := protocol.ReadVaruint32(r)
										if err != nil {
											return err
										}
										if lengthUint < 1 {
											return errors.New("invalid compact array length")
										}
										length = int32(lengthUint - 1)
										m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopicRegex = make([]int16, length)
										for i := int32(0); i < length; i++ {
											val, err := protocol.ReadInt16(r)
											if err != nil {
												return err
											}
											m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopicRegex[i] = val
										}
									} else {
										var err error
										length, err = protocol.ReadInt32(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopicRegex = make([]int16, length)
										for i := int32(0); i < length; i++ {
											val, err := protocol.ReadInt16(r)
											if err != nil {
												return err
											}
											m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopicRegex[i] = val
										}
									}
								}
								// RepartitionSourceTopics
								if version >= 0 && version <= 999 {
									var length int32
									if isFlexible {
										var lengthUint uint32
										lengthUint, err := protocol.ReadVaruint32(r)
										if err != nil {
											return err
										}
										if lengthUint < 1 {
											return errors.New("invalid compact array length")
										}
										length = int32(lengthUint - 1)
										m.Topology.Subtopologies[i].CopartitionGroups[i].RepartitionSourceTopics = make([]int16, length)
										for i := int32(0); i < length; i++ {
											val, err := protocol.ReadInt16(r)
											if err != nil {
												return err
											}
											m.Topology.Subtopologies[i].CopartitionGroups[i].RepartitionSourceTopics[i] = val
										}
									} else {
										var err error
										length, err = protocol.ReadInt32(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].CopartitionGroups[i].RepartitionSourceTopics = make([]int16, length)
										for i := int32(0); i < length; i++ {
											val, err := protocol.ReadInt16(r)
											if err != nil {
												return err
											}
											m.Topology.Subtopologies[i].CopartitionGroups[i].RepartitionSourceTopics[i] = val
										}
									}
								}
							}
						} else {
							var err error
							length, err = protocol.ReadInt32(r)
							if err != nil {
								return err
							}
							m.Topology.Subtopologies[i].CopartitionGroups = make([]StreamsGroupHeartbeatRequestCopartitionGroup, length)
							for i := int32(0); i < length; i++ {
								// SourceTopics
								if version >= 0 && version <= 999 {
									var length int32
									if isFlexible {
										var lengthUint uint32
										lengthUint, err := protocol.ReadVaruint32(r)
										if err != nil {
											return err
										}
										if lengthUint < 1 {
											return errors.New("invalid compact array length")
										}
										length = int32(lengthUint - 1)
										m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopics = make([]int16, length)
										for i := int32(0); i < length; i++ {
											val, err := protocol.ReadInt16(r)
											if err != nil {
												return err
											}
											m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopics[i] = val
										}
									} else {
										var err error
										length, err = protocol.ReadInt32(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopics = make([]int16, length)
										for i := int32(0); i < length; i++ {
											val, err := protocol.ReadInt16(r)
											if err != nil {
												return err
											}
											m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopics[i] = val
										}
									}
								}
								// SourceTopicRegex
								if version >= 0 && version <= 999 {
									var length int32
									if isFlexible {
										var lengthUint uint32
										lengthUint, err := protocol.ReadVaruint32(r)
										if err != nil {
											return err
										}
										if lengthUint < 1 {
											return errors.New("invalid compact array length")
										}
										length = int32(lengthUint - 1)
										m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopicRegex = make([]int16, length)
										for i := int32(0); i < length; i++ {
											val, err := protocol.ReadInt16(r)
											if err != nil {
												return err
											}
											m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopicRegex[i] = val
										}
									} else {
										var err error
										length, err = protocol.ReadInt32(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopicRegex = make([]int16, length)
										for i := int32(0); i < length; i++ {
											val, err := protocol.ReadInt16(r)
											if err != nil {
												return err
											}
											m.Topology.Subtopologies[i].CopartitionGroups[i].SourceTopicRegex[i] = val
										}
									}
								}
								// RepartitionSourceTopics
								if version >= 0 && version <= 999 {
									var length int32
									if isFlexible {
										var lengthUint uint32
										lengthUint, err := protocol.ReadVaruint32(r)
										if err != nil {
											return err
										}
										if lengthUint < 1 {
											return errors.New("invalid compact array length")
										}
										length = int32(lengthUint - 1)
										m.Topology.Subtopologies[i].CopartitionGroups[i].RepartitionSourceTopics = make([]int16, length)
										for i := int32(0); i < length; i++ {
											val, err := protocol.ReadInt16(r)
											if err != nil {
												return err
											}
											m.Topology.Subtopologies[i].CopartitionGroups[i].RepartitionSourceTopics[i] = val
										}
									} else {
										var err error
										length, err = protocol.ReadInt32(r)
										if err != nil {
											return err
										}
										m.Topology.Subtopologies[i].CopartitionGroups[i].RepartitionSourceTopics = make([]int16, length)
										for i := int32(0); i < length; i++ {
											val, err := protocol.ReadInt16(r)
											if err != nil {
												return err
											}
											m.Topology.Subtopologies[i].CopartitionGroups[i].RepartitionSourceTopics[i] = val
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	// ActiveTasks
	if version >= 0 && version <= 999 {
		var length int32
		if isFlexible {
			var lengthUint uint32
			lengthUint, err := protocol.ReadVaruint32(r)
			if err != nil {
				return err
			}
			if lengthUint == 0 {
				m.ActiveTasks = nil
			} else {
				if lengthUint < 1 {
					return errors.New("invalid compact array length")
				}
				length = int32(lengthUint - 1)
				m.ActiveTasks = make([]TaskIds, length)
				for i := int32(0); i < length; i++ {
					// SubtopologyId
					if version >= 0 && version <= 999 {
						if isFlexible {
							val, err := protocol.ReadCompactString(r)
							if err != nil {
								return err
							}
							m.ActiveTasks[i].SubtopologyId = val
						} else {
							val, err := protocol.ReadString(r)
							if err != nil {
								return err
							}
							m.ActiveTasks[i].SubtopologyId = val
						}
					}
					// Partitions
					if version >= 0 && version <= 999 {
						var length int32
						if isFlexible {
							var lengthUint uint32
							lengthUint, err := protocol.ReadVaruint32(r)
							if err != nil {
								return err
							}
							if lengthUint < 1 {
								return errors.New("invalid compact array length")
							}
							length = int32(lengthUint - 1)
							m.ActiveTasks[i].Partitions = make([]int32, length)
							for i := int32(0); i < length; i++ {
								val, err := protocol.ReadInt32(r)
								if err != nil {
									return err
								}
								m.ActiveTasks[i].Partitions[i] = val
							}
						} else {
							var err error
							length, err = protocol.ReadInt32(r)
							if err != nil {
								return err
							}
							m.ActiveTasks[i].Partitions = make([]int32, length)
							for i := int32(0); i < length; i++ {
								val, err := protocol.ReadInt32(r)
								if err != nil {
									return err
								}
								m.ActiveTasks[i].Partitions[i] = val
							}
						}
					}
				}
			}
		} else {
			var err error
			length, err = protocol.ReadInt32(r)
			if err != nil {
				return err
			}
			if length == -1 {
				m.ActiveTasks = nil
			} else {
				m.ActiveTasks = make([]TaskIds, length)
				for i := int32(0); i < length; i++ {
					// SubtopologyId
					if version >= 0 && version <= 999 {
						if isFlexible {
							val, err := protocol.ReadCompactString(r)
							if err != nil {
								return err
							}
							m.ActiveTasks[i].SubtopologyId = val
						} else {
							val, err := protocol.ReadString(r)
							if err != nil {
								return err
							}
							m.ActiveTasks[i].SubtopologyId = val
						}
					}
					// Partitions
					if version >= 0 && version <= 999 {
						var length int32
						if isFlexible {
							var lengthUint uint32
							lengthUint, err := protocol.ReadVaruint32(r)
							if err != nil {
								return err
							}
							if lengthUint < 1 {
								return errors.New("invalid compact array length")
							}
							length = int32(lengthUint - 1)
							m.ActiveTasks[i].Partitions = make([]int32, length)
							for i := int32(0); i < length; i++ {
								val, err := protocol.ReadInt32(r)
								if err != nil {
									return err
								}
								m.ActiveTasks[i].Partitions[i] = val
							}
						} else {
							var err error
							length, err = protocol.ReadInt32(r)
							if err != nil {
								return err
							}
							m.ActiveTasks[i].Partitions = make([]int32, length)
							for i := int32(0); i < length; i++ {
								val, err := protocol.ReadInt32(r)
								if err != nil {
									return err
								}
								m.ActiveTasks[i].Partitions[i] = val
							}
						}
					}
				}
			}
		}
	}
	// StandbyTasks
	if version >= 0 && version <= 999 {
		var length int32
		if isFlexible {
			var lengthUint uint32
			lengthUint, err := protocol.ReadVaruint32(r)
			if err != nil {
				return err
			}
			if lengthUint == 0 {
				m.StandbyTasks = nil
			} else {
				if lengthUint < 1 {
					return errors.New("invalid compact array length")
				}
				length = int32(lengthUint - 1)
				m.StandbyTasks = make([]TaskIds, length)
				for i := int32(0); i < length; i++ {
					// SubtopologyId
					if version >= 0 && version <= 999 {
						if isFlexible {
							val, err := protocol.ReadCompactString(r)
							if err != nil {
								return err
							}
							m.StandbyTasks[i].SubtopologyId = val
						} else {
							val, err := protocol.ReadString(r)
							if err != nil {
								return err
							}
							m.StandbyTasks[i].SubtopologyId = val
						}
					}
					// Partitions
					if version >= 0 && version <= 999 {
						var length int32
						if isFlexible {
							var lengthUint uint32
							lengthUint, err := protocol.ReadVaruint32(r)
							if err != nil {
								return err
							}
							if lengthUint < 1 {
								return errors.New("invalid compact array length")
							}
							length = int32(lengthUint - 1)
							m.StandbyTasks[i].Partitions = make([]int32, length)
							for i := int32(0); i < length; i++ {
								val, err := protocol.ReadInt32(r)
								if err != nil {
									return err
								}
								m.StandbyTasks[i].Partitions[i] = val
							}
						} else {
							var err error
							length, err = protocol.ReadInt32(r)
							if err != nil {
								return err
							}
							m.StandbyTasks[i].Partitions = make([]int32, length)
							for i := int32(0); i < length; i++ {
								val, err := protocol.ReadInt32(r)
								if err != nil {
									return err
								}
								m.StandbyTasks[i].Partitions[i] = val
							}
						}
					}
				}
			}
		} else {
			var err error
			length, err = protocol.ReadInt32(r)
			if err != nil {
				return err
			}
			if length == -1 {
				m.StandbyTasks = nil
			} else {
				m.StandbyTasks = make([]TaskIds, length)
				for i := int32(0); i < length; i++ {
					// SubtopologyId
					if version >= 0 && version <= 999 {
						if isFlexible {
							val, err := protocol.ReadCompactString(r)
							if err != nil {
								return err
							}
							m.StandbyTasks[i].SubtopologyId = val
						} else {
							val, err := protocol.ReadString(r)
							if err != nil {
								return err
							}
							m.StandbyTasks[i].SubtopologyId = val
						}
					}
					// Partitions
					if version >= 0 && version <= 999 {
						var length int32
						if isFlexible {
							var lengthUint uint32
							lengthUint, err := protocol.ReadVaruint32(r)
							if err != nil {
								return err
							}
							if lengthUint < 1 {
								return errors.New("invalid compact array length")
							}
							length = int32(lengthUint - 1)
							m.StandbyTasks[i].Partitions = make([]int32, length)
							for i := int32(0); i < length; i++ {
								val, err := protocol.ReadInt32(r)
								if err != nil {
									return err
								}
								m.StandbyTasks[i].Partitions[i] = val
							}
						} else {
							var err error
							length, err = protocol.ReadInt32(r)
							if err != nil {
								return err
							}
							m.StandbyTasks[i].Partitions = make([]int32, length)
							for i := int32(0); i < length; i++ {
								val, err := protocol.ReadInt32(r)
								if err != nil {
									return err
								}
								m.StandbyTasks[i].Partitions[i] = val
							}
						}
					}
				}
			}
		}
	}
	// WarmupTasks
	if version >= 0 && version <= 999 {
		var length int32
		if isFlexible {
			var lengthUint uint32
			lengthUint, err := protocol.ReadVaruint32(r)
			if err != nil {
				return err
			}
			if lengthUint == 0 {
				m.WarmupTasks = nil
			} else {
				if lengthUint < 1 {
					return errors.New("invalid compact array length")
				}
				length = int32(lengthUint - 1)
				m.WarmupTasks = make([]TaskIds, length)
				for i := int32(0); i < length; i++ {
					// SubtopologyId
					if version >= 0 && version <= 999 {
						if isFlexible {
							val, err := protocol.ReadCompactString(r)
							if err != nil {
								return err
							}
							m.WarmupTasks[i].SubtopologyId = val
						} else {
							val, err := protocol.ReadString(r)
							if err != nil {
								return err
							}
							m.WarmupTasks[i].SubtopologyId = val
						}
					}
					// Partitions
					if version >= 0 && version <= 999 {
						var length int32
						if isFlexible {
							var lengthUint uint32
							lengthUint, err := protocol.ReadVaruint32(r)
							if err != nil {
								return err
							}
							if lengthUint < 1 {
								return errors.New("invalid compact array length")
							}
							length = int32(lengthUint - 1)
							m.WarmupTasks[i].Partitions = make([]int32, length)
							for i := int32(0); i < length; i++ {
								val, err := protocol.ReadInt32(r)
								if err != nil {
									return err
								}
								m.WarmupTasks[i].Partitions[i] = val
							}
						} else {
							var err error
							length, err = protocol.ReadInt32(r)
							if err != nil {
								return err
							}
							m.WarmupTasks[i].Partitions = make([]int32, length)
							for i := int32(0); i < length; i++ {
								val, err := protocol.ReadInt32(r)
								if err != nil {
									return err
								}
								m.WarmupTasks[i].Partitions[i] = val
							}
						}
					}
				}
			}
		} else {
			var err error
			length, err = protocol.ReadInt32(r)
			if err != nil {
				return err
			}
			if length == -1 {
				m.WarmupTasks = nil
			} else {
				m.WarmupTasks = make([]TaskIds, length)
				for i := int32(0); i < length; i++ {
					// SubtopologyId
					if version >= 0 && version <= 999 {
						if isFlexible {
							val, err := protocol.ReadCompactString(r)
							if err != nil {
								return err
							}
							m.WarmupTasks[i].SubtopologyId = val
						} else {
							val, err := protocol.ReadString(r)
							if err != nil {
								return err
							}
							m.WarmupTasks[i].SubtopologyId = val
						}
					}
					// Partitions
					if version >= 0 && version <= 999 {
						var length int32
						if isFlexible {
							var lengthUint uint32
							lengthUint, err := protocol.ReadVaruint32(r)
							if err != nil {
								return err
							}
							if lengthUint < 1 {
								return errors.New("invalid compact array length")
							}
							length = int32(lengthUint - 1)
							m.WarmupTasks[i].Partitions = make([]int32, length)
							for i := int32(0); i < length; i++ {
								val, err := protocol.ReadInt32(r)
								if err != nil {
									return err
								}
								m.WarmupTasks[i].Partitions[i] = val
							}
						} else {
							var err error
							length, err = protocol.ReadInt32(r)
							if err != nil {
								return err
							}
							m.WarmupTasks[i].Partitions = make([]int32, length)
							for i := int32(0); i < length; i++ {
								val, err := protocol.ReadInt32(r)
								if err != nil {
									return err
								}
								m.WarmupTasks[i].Partitions[i] = val
							}
						}
					}
				}
			}
		}
	}
	// ProcessId
	if version >= 0 && version <= 999 {
		if isFlexible {
			val, err := protocol.ReadCompactNullableString(r)
			if err != nil {
				return err
			}
			m.ProcessId = val
		} else {
			val, err := protocol.ReadNullableString(r)
			if err != nil {
				return err
			}
			m.ProcessId = val
		}
	}
	// UserEndpoint
	if version >= 0 && version <= 999 {
	}
	// ClientTags
	if version >= 0 && version <= 999 {
		var length int32
		if isFlexible {
			var lengthUint uint32
			lengthUint, err := protocol.ReadVaruint32(r)
			if err != nil {
				return err
			}
			if lengthUint == 0 {
				m.ClientTags = nil
			} else {
				if lengthUint < 1 {
					return errors.New("invalid compact array length")
				}
				length = int32(lengthUint - 1)
				m.ClientTags = make([]KeyValue, length)
				for i := int32(0); i < length; i++ {
					// Key
					if version >= 0 && version <= 999 {
						if isFlexible {
							val, err := protocol.ReadCompactString(r)
							if err != nil {
								return err
							}
							m.ClientTags[i].Key = val
						} else {
							val, err := protocol.ReadString(r)
							if err != nil {
								return err
							}
							m.ClientTags[i].Key = val
						}
					}
					// Value
					if version >= 0 && version <= 999 {
						if isFlexible {
							val, err := protocol.ReadCompactString(r)
							if err != nil {
								return err
							}
							m.ClientTags[i].Value = val
						} else {
							val, err := protocol.ReadString(r)
							if err != nil {
								return err
							}
							m.ClientTags[i].Value = val
						}
					}
				}
			}
		} else {
			var err error
			length, err = protocol.ReadInt32(r)
			if err != nil {
				return err
			}
			if length == -1 {
				m.ClientTags = nil
			} else {
				m.ClientTags = make([]KeyValue, length)
				for i := int32(0); i < length; i++ {
					// Key
					if version >= 0 && version <= 999 {
						if isFlexible {
							val, err := protocol.ReadCompactString(r)
							if err != nil {
								return err
							}
							m.ClientTags[i].Key = val
						} else {
							val, err := protocol.ReadString(r)
							if err != nil {
								return err
							}
							m.ClientTags[i].Key = val
						}
					}
					// Value
					if version >= 0 && version <= 999 {
						if isFlexible {
							val, err := protocol.ReadCompactString(r)
							if err != nil {
								return err
							}
							m.ClientTags[i].Value = val
						} else {
							val, err := protocol.ReadString(r)
							if err != nil {
								return err
							}
							m.ClientTags[i].Value = val
						}
					}
				}
			}
		}
	}
	// TaskOffsets
	if version >= 0 && version <= 999 {
		var length int32
		if isFlexible {
			var lengthUint uint32
			lengthUint, err := protocol.ReadVaruint32(r)
			if err != nil {
				return err
			}
			if lengthUint == 0 {
				m.TaskOffsets = nil
			} else {
				if lengthUint < 1 {
					return errors.New("invalid compact array length")
				}
				length = int32(lengthUint - 1)
				m.TaskOffsets = make([]TaskOffset, length)
				for i := int32(0); i < length; i++ {
					// SubtopologyId
					if version >= 0 && version <= 999 {
						if isFlexible {
							val, err := protocol.ReadCompactString(r)
							if err != nil {
								return err
							}
							m.TaskOffsets[i].SubtopologyId = val
						} else {
							val, err := protocol.ReadString(r)
							if err != nil {
								return err
							}
							m.TaskOffsets[i].SubtopologyId = val
						}
					}
					// Partition
					if version >= 0 && version <= 999 {
						val, err := protocol.ReadInt32(r)
						if err != nil {
							return err
						}
						m.TaskOffsets[i].Partition = val
					}
					// Offset
					if version >= 0 && version <= 999 {
						val, err := protocol.ReadInt64(r)
						if err != nil {
							return err
						}
						m.TaskOffsets[i].Offset = val
					}
				}
			}
		} else {
			var err error
			length, err = protocol.ReadInt32(r)
			if err != nil {
				return err
			}
			if length == -1 {
				m.TaskOffsets = nil
			} else {
				m.TaskOffsets = make([]TaskOffset, length)
				for i := int32(0); i < length; i++ {
					// SubtopologyId
					if version >= 0 && version <= 999 {
						if isFlexible {
							val, err := protocol.ReadCompactString(r)
							if err != nil {
								return err
							}
							m.TaskOffsets[i].SubtopologyId = val
						} else {
							val, err := protocol.ReadString(r)
							if err != nil {
								return err
							}
							m.TaskOffsets[i].SubtopologyId = val
						}
					}
					// Partition
					if version >= 0 && version <= 999 {
						val, err := protocol.ReadInt32(r)
						if err != nil {
							return err
						}
						m.TaskOffsets[i].Partition = val
					}
					// Offset
					if version >= 0 && version <= 999 {
						val, err := protocol.ReadInt64(r)
						if err != nil {
							return err
						}
						m.TaskOffsets[i].Offset = val
					}
				}
			}
		}
	}
	// TaskEndOffsets
	if version >= 0 && version <= 999 {
		var length int32
		if isFlexible {
			var lengthUint uint32
			lengthUint, err := protocol.ReadVaruint32(r)
			if err != nil {
				return err
			}
			if lengthUint == 0 {
				m.TaskEndOffsets = nil
			} else {
				if lengthUint < 1 {
					return errors.New("invalid compact array length")
				}
				length = int32(lengthUint - 1)
				m.TaskEndOffsets = make([]TaskOffset, length)
				for i := int32(0); i < length; i++ {
					// SubtopologyId
					if version >= 0 && version <= 999 {
						if isFlexible {
							val, err := protocol.ReadCompactString(r)
							if err != nil {
								return err
							}
							m.TaskEndOffsets[i].SubtopologyId = val
						} else {
							val, err := protocol.ReadString(r)
							if err != nil {
								return err
							}
							m.TaskEndOffsets[i].SubtopologyId = val
						}
					}
					// Partition
					if version >= 0 && version <= 999 {
						val, err := protocol.ReadInt32(r)
						if err != nil {
							return err
						}
						m.TaskEndOffsets[i].Partition = val
					}
					// Offset
					if version >= 0 && version <= 999 {
						val, err := protocol.ReadInt64(r)
						if err != nil {
							return err
						}
						m.TaskEndOffsets[i].Offset = val
					}
				}
			}
		} else {
			var err error
			length, err = protocol.ReadInt32(r)
			if err != nil {
				return err
			}
			if length == -1 {
				m.TaskEndOffsets = nil
			} else {
				m.TaskEndOffsets = make([]TaskOffset, length)
				for i := int32(0); i < length; i++ {
					// SubtopologyId
					if version >= 0 && version <= 999 {
						if isFlexible {
							val, err := protocol.ReadCompactString(r)
							if err != nil {
								return err
							}
							m.TaskEndOffsets[i].SubtopologyId = val
						} else {
							val, err := protocol.ReadString(r)
							if err != nil {
								return err
							}
							m.TaskEndOffsets[i].SubtopologyId = val
						}
					}
					// Partition
					if version >= 0 && version <= 999 {
						val, err := protocol.ReadInt32(r)
						if err != nil {
							return err
						}
						m.TaskEndOffsets[i].Partition = val
					}
					// Offset
					if version >= 0 && version <= 999 {
						val, err := protocol.ReadInt64(r)
						if err != nil {
							return err
						}
						m.TaskEndOffsets[i].Offset = val
					}
				}
			}
		}
	}
	// ShutdownApplication
	if version >= 0 && version <= 999 {
		val, err := protocol.ReadBool(r)
		if err != nil {
			return err
		}
		m.ShutdownApplication = val
	}
	// Read tagged fields if flexible
	if isFlexible {
		if err := m.readTaggedFields(r, version); err != nil {
			return err
		}
	}
	return nil
}

// StreamsGroupHeartbeatRequestTopology represents The topology metadata of the streams application. Used to initialize the topology of the group and to check if the topology corresponds to the topology initialized for the group. Only sent when memberEpoch = 0, must be non-empty. Null otherwise..
type StreamsGroupHeartbeatRequestTopology struct {
	// The epoch of the topology. Used to check if the topology corresponds to the topology initialized on the brokers.
	Epoch int32 `json:"epoch" versions:"0-999"`
	// The sub-topologies of the streams application.
	Subtopologies []StreamsGroupHeartbeatRequestSubtopology `json:"subtopologies" versions:"0-999"`
}

// StreamsGroupHeartbeatRequestSubtopology represents The sub-topologies of the streams application..
type StreamsGroupHeartbeatRequestSubtopology struct {
	// String to uniquely identify the subtopology. Deterministically generated from the topology
	SubtopologyId string `json:"subtopologyid" versions:"0-999"`
	// The topics the topology reads from.
	SourceTopics []string `json:"sourcetopics" versions:"0-999"`
	// The regular expressions identifying topics the subtopology reads from.
	SourceTopicRegex []string `json:"sourcetopicregex" versions:"0-999"`
	// The set of state changelog topics associated with this subtopology. Created automatically.
	StateChangelogTopics []TopicInfo `json:"statechangelogtopics" versions:"0-999"`
	// The repartition topics the subtopology writes to.
	RepartitionSinkTopics []string `json:"repartitionsinktopics" versions:"0-999"`
	// The set of source topics that are internally created repartition topics. Created automatically.
	RepartitionSourceTopics []TopicInfo `json:"repartitionsourcetopics" versions:"0-999"`
	// A subset of source topics that must be copartitioned.
	CopartitionGroups []StreamsGroupHeartbeatRequestCopartitionGroup `json:"copartitiongroups" versions:"0-999"`
}

// StreamsGroupHeartbeatRequestCopartitionGroup represents A subset of source topics that must be copartitioned..
type StreamsGroupHeartbeatRequestCopartitionGroup struct {
	// The topics the topology reads from. Index into the array on the subtopology level.
	SourceTopics []int16 `json:"sourcetopics" versions:"0-999"`
	// Regular expressions identifying topics the subtopology reads from. Index into the array on the subtopology level.
	SourceTopicRegex []int16 `json:"sourcetopicregex" versions:"0-999"`
	// The set of source topics that are internally created repartition topics. Index into the array on the subtopology level.
	RepartitionSourceTopics []int16 `json:"repartitionsourcetopics" versions:"0-999"`
}

// TopicPartition represents .
type TopicPartition struct {
	// topic name
	Topic string `json:"topic" versions:"0-999"`
	// partitions
	Partitions []int32 `json:"partitions" versions:"0-999"`
}

// KeyValue represents .
type KeyValue struct {
	// key of the config
	Key string `json:"key" versions:"0-999"`
	// value of the config
	Value string `json:"value" versions:"0-999"`
}

// TopicInfo represents .
type TopicInfo struct {
	// The name of the topic.
	Name string `json:"name" versions:"0-999"`
	// The number of partitions in the topic. Can be 0 if no specific number of partitions is enforced. Always 0 for changelog topics.
	Partitions int32 `json:"partitions" versions:"0-999"`
	// The replication factor of the topic. Can be 0 if the default replication factor should be used.
	ReplicationFactor int16 `json:"replicationfactor" versions:"0-999"`
	// Topic-level configurations as key-value pairs.
	TopicConfigs []KeyValue `json:"topicconfigs" versions:"0-999"`
}

// Endpoint represents .
type Endpoint struct {
	// host of the endpoint
	Host string `json:"host" versions:"0-999"`
	// port of the endpoint
	Port uint16 `json:"port" versions:"0-999"`
}

// TaskOffset represents .
type TaskOffset struct {
	// The subtopology identifier.
	SubtopologyId string `json:"subtopologyid" versions:"0-999"`
	// The partition.
	Partition int32 `json:"partition" versions:"0-999"`
	// The offset.
	Offset int64 `json:"offset" versions:"0-999"`
}

// TaskIds represents .
type TaskIds struct {
	// The subtopology identifier.
	SubtopologyId string `json:"subtopologyid" versions:"0-999"`
	// The partitions of the input topics processed by this member.
	Partitions []int32 `json:"partitions" versions:"0-999"`
}

// Status represents .
type Status struct {
	// A code to indicate that a particular status is active for the group membership
	StatusCode int8 `json:"statuscode" versions:"0-999"`
	// A string representation of the status.
	StatusDetail string `json:"statusdetail" versions:"0-999"`
}

// writeTaggedFields writes tagged fields for StreamsGroupHeartbeatRequest.
func (m *StreamsGroupHeartbeatRequest) writeTaggedFields(w io.Writer, version int16) error {
	var taggedFieldsCount int
	var taggedFieldsBuf bytes.Buffer

	// Write tagged fields count
	if err := protocol.WriteVaruint32(w, uint32(taggedFieldsCount)); err != nil {
		return err
	}

	// Write tagged fields data
	if taggedFieldsCount > 0 {
		if _, err := w.Write(taggedFieldsBuf.Bytes()); err != nil {
			return err
		}
	}

	return nil
}

// readTaggedFields reads tagged fields for StreamsGroupHeartbeatRequest.
func (m *StreamsGroupHeartbeatRequest) readTaggedFields(r io.Reader, version int16) error {
	// Read tagged fields count
	count, err := protocol.ReadVaruint32(r)
	if err != nil {
		return err
	}

	if count == 0 {
		return nil
	}

	// Read tagged fields
	for i := uint32(0); i < count; i++ {
		tag, err := protocol.ReadVaruint32(r)
		if err != nil {
			return err
		}

		switch tag {
		default:
			// Unknown tag, skip it
			// Read and discard the field data
			// For now, we'll need to know the type to skip properly
			// This is a simplified implementation
		}
	}

	return nil
}
